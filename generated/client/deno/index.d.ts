
/**
 * Client
**/

import * as runtime from '.././runtime/index.d.ts';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Message
 * 
 */
export type Message = {
  id: number
  body: string
  createdAt: Date
  userId: string
}

/**
 * Model Account
 * 
 */
export type Account = {
  id: number
  compoundId: string
  userId: string
  providerType: string
  providerId: string
  providerAccountId: string
  refreshToken: string | null
  accessToken: string | null
  accessTokenExpires: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: number
  userId: string
  expires: Date
  sessionToken: string
  accessToken: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model City
 * 
 */
export type City = {
  id: number
  name: string
  addressId: number | null
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: number
  zip: number
  deliveryId: number | null
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  productId: string | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  title: string
  description: string
  image: string
  sku: string
  quantity: number
  price: number
  createdAt: Date
  updatedAt: Date
  userId: string | null
}

/**
 * Model Delivery
 * 
 */
export type Delivery = {
  id: number
  title: string
}

/**
 * Model VerificationRequest
 * 
 */
export type VerificationRequest = {
  id: number
  identifier: string
  token: string
  expires: Date
  createdAt: Date
  updatedAt: Date
  userId: string
}

/**
 * Model product_category
 * 
 */
export type product_category = {
  id: number
  name: string
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string
  password: string
  username: string | null
  first_name: string | null
  last_name: string | null
  phone_user: string | null
  trademark: string | null
  locale_user: string | null
  image_url_user: string | null
  auth_is_telegram: boolean
  auth_is_yandex: boolean
  auth_is_google: boolean
  role: string
  bio: string | null
  createdAt: Date
  updatedAt: Date
  emailDateVerified: Date | null
}

/**
 * Model ProductsProduct
 * 
 */
export type ProductsProduct = {
  id: string
  count: number
  next: number
  previous: number
}

/**
 * Model ProductsProductResult
 * 
 */
export type ProductsProductResult = {
  id: string
  userId: string | null
  name: string | null
  image: string | null
  text: string | null
  price_product: number | null
  taxation: string | null
  tax: string | null
  authorProductId: string | null
  productsProductId: string | null
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: number
  order_id: string
  purchaseDate: Date
  description: string
  userId: string
  productId: string
  deliveryId: number | null
}

/**
 * Model products_product_category
 * 
 */
export type products_product_category = {
  id: number
  product_id: number
  category_id: number
}

/**
 * Model products_tag
 * 
 */
export type products_tag = {
  id: number
  name: string
  color: string
  slug: string
  key: number | null
}

/**
 * Model products_product_tags
 * 
 */
export type products_product_tags = {
  id: number
  producy_id: number
  tag_id: number
}

/**
 * Model ProductsProductWhoLikesIt
 * 
 */
export type ProductsProductWhoLikesIt = {
  id: number
  product_id: number
  user_id: number
}

/**
 * Model payments_productbuyers
 * 
 */
export type payments_productbuyers = {
  id: string
  amount: number
  backUrl: string | null
  companyName: string | null
  details: string | null
  emailReq: string | null
  errorCode: string | null
  merchantEmail: string | null
  merchantName: string | null
  message: string | null
  orderId: string
  paymentId: string
  phoneReq: string | null
  success: string | null
  tranDate: string | null
}

/**
 * Model AuthorProduct
 * 
 */
export type AuthorProduct = {
  id: string
  email: string
  username: string | null
  first_name: string | null
  last_name: string | null
  is_subscribed: boolean | null
  phone_user: string | null
  trademark: string | null
  locale_user: string | null
  image_url_user: string | null
  image_file_user: string | null
  auth_is_telegram: boolean
  auth_is_yandex: boolean
  auth_is_google: boolean
  is_admin_constructor: boolean
}

/**
 * Model Tags
 * 
 */
export type Tags = {
  id: number
  name: string | null
  color: string | null
  slug: string | null
  productsProductResultId: number | null
}

/**
 * Model UserFavoritesProduct
 * 
 */
export type UserFavoritesProduct = {
  id: number
  is_favorite: boolean
  userId: string
  productId: string
}

/**
 * Model Vote
 * 
 */
export type Vote = {
  id: number
  count_votes: number
  is_vote_user: boolean
  productId: string | null
  userId: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Messages
 * const messages = await prisma.message.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Messages
   * const messages = await prisma.message.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<GlobalReject>;

  /**
   * `prisma.verificationRequest`: Exposes CRUD operations for the **VerificationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationRequests
    * const verificationRequests = await prisma.verificationRequest.findMany()
    * ```
    */
  get verificationRequest(): Prisma.VerificationRequestDelegate<GlobalReject>;

  /**
   * `prisma.product_category`: Exposes CRUD operations for the **product_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_categories
    * const product_categories = await prisma.product_category.findMany()
    * ```
    */
  get product_category(): Prisma.product_categoryDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.productsProduct`: Exposes CRUD operations for the **ProductsProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductsProducts
    * const productsProducts = await prisma.productsProduct.findMany()
    * ```
    */
  get productsProduct(): Prisma.ProductsProductDelegate<GlobalReject>;

  /**
   * `prisma.productsProductResult`: Exposes CRUD operations for the **ProductsProductResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductsProductResults
    * const productsProductResults = await prisma.productsProductResult.findMany()
    * ```
    */
  get productsProductResult(): Prisma.ProductsProductResultDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.products_product_category`: Exposes CRUD operations for the **products_product_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products_product_categories
    * const products_product_categories = await prisma.products_product_category.findMany()
    * ```
    */
  get products_product_category(): Prisma.products_product_categoryDelegate<GlobalReject>;

  /**
   * `prisma.products_tag`: Exposes CRUD operations for the **products_tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products_tags
    * const products_tags = await prisma.products_tag.findMany()
    * ```
    */
  get products_tag(): Prisma.products_tagDelegate<GlobalReject>;

  /**
   * `prisma.products_product_tags`: Exposes CRUD operations for the **products_product_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products_product_tags
    * const products_product_tags = await prisma.products_product_tags.findMany()
    * ```
    */
  get products_product_tags(): Prisma.products_product_tagsDelegate<GlobalReject>;

  /**
   * `prisma.productsProductWhoLikesIt`: Exposes CRUD operations for the **ProductsProductWhoLikesIt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductsProductWhoLikesIts
    * const productsProductWhoLikesIts = await prisma.productsProductWhoLikesIt.findMany()
    * ```
    */
  get productsProductWhoLikesIt(): Prisma.ProductsProductWhoLikesItDelegate<GlobalReject>;

  /**
   * `prisma.payments_productbuyers`: Exposes CRUD operations for the **payments_productbuyers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments_productbuyers
    * const payments_productbuyers = await prisma.payments_productbuyers.findMany()
    * ```
    */
  get payments_productbuyers(): Prisma.payments_productbuyersDelegate<GlobalReject>;

  /**
   * `prisma.authorProduct`: Exposes CRUD operations for the **AuthorProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorProducts
    * const authorProducts = await prisma.authorProduct.findMany()
    * ```
    */
  get authorProduct(): Prisma.AuthorProductDelegate<GlobalReject>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<GlobalReject>;

  /**
   * `prisma.userFavoritesProduct`: Exposes CRUD operations for the **UserFavoritesProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavoritesProducts
    * const userFavoritesProducts = await prisma.userFavoritesProduct.findMany()
    * ```
    */
  get userFavoritesProduct(): Prisma.UserFavoritesProductDelegate<GlobalReject>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.8.1
   * Query Engine version: d6e67a83f971b175a593ccc12e15c4a757f93ffe
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Message: 'Message',
    Account: 'Account',
    Session: 'Session',
    City: 'City',
    Address: 'Address',
    Category: 'Category',
    Product: 'Product',
    Delivery: 'Delivery',
    VerificationRequest: 'VerificationRequest',
    product_category: 'product_category',
    User: 'User',
    ProductsProduct: 'ProductsProduct',
    ProductsProductResult: 'ProductsProductResult',
    Order: 'Order',
    products_product_category: 'products_product_category',
    products_tag: 'products_tag',
    products_product_tags: 'products_product_tags',
    ProductsProductWhoLikesIt: 'ProductsProductWhoLikesIt',
    payments_productbuyers: 'payments_productbuyers',
    AuthorProduct: 'AuthorProduct',
    Tags: 'Tags',
    UserFavoritesProduct: 'UserFavoritesProduct',
    Vote: 'Vote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AddressCountOutputType
   */


  export type AddressCountOutputType = {
    city: number
  }

  export type AddressCountOutputTypeSelect = {
    city?: boolean
  }

  export type AddressCountOutputTypeGetPayload<S extends boolean | null | undefined | AddressCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AddressCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AddressCountOutputTypeArgs)
    ? AddressCountOutputType 
    : S extends { select: any } & (AddressCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AddressCountOutputType ? AddressCountOutputType[P] : never
  } 
      : AddressCountOutputType




  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     * 
    **/
    select?: AddressCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect = {
    products?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryCountOutputTypeArgs)
    ? CategoryCountOutputType 
    : S extends { select: any } & (CategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
      : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    categories: number
    orders: number
  }

  export type ProductCountOutputTypeSelect = {
    categories?: boolean
    orders?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type DeliveryCountOutputType
   */


  export type DeliveryCountOutputType = {
    address: number
    orders: number
  }

  export type DeliveryCountOutputTypeSelect = {
    address?: boolean
    orders?: boolean
  }

  export type DeliveryCountOutputTypeGetPayload<S extends boolean | null | undefined | DeliveryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DeliveryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DeliveryCountOutputTypeArgs)
    ? DeliveryCountOutputType 
    : S extends { select: any } & (DeliveryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DeliveryCountOutputType ? DeliveryCountOutputType[P] : never
  } 
      : DeliveryCountOutputType




  // Custom InputTypes

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     * 
    **/
    select?: DeliveryCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    messages: number
    orders: number
    products: number
    verifiedUsers: number
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect = {
    messages?: boolean
    orders?: boolean
    products?: boolean
    verifiedUsers?: boolean
    accounts?: boolean
    sessions?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductsProductCountOutputType
   */


  export type ProductsProductCountOutputType = {
    results: number
  }

  export type ProductsProductCountOutputTypeSelect = {
    results?: boolean
  }

  export type ProductsProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductsProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductsProductCountOutputTypeArgs)
    ? ProductsProductCountOutputType 
    : S extends { select: any } & (ProductsProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductsProductCountOutputType ? ProductsProductCountOutputType[P] : never
  } 
      : ProductsProductCountOutputType




  // Custom InputTypes

  /**
   * ProductsProductCountOutputType without action
   */
  export type ProductsProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductCountOutputType
     * 
    **/
    select?: ProductsProductCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductsProductResultCountOutputType
   */


  export type ProductsProductResultCountOutputType = {
    tags: number
    productsProduct: number
  }

  export type ProductsProductResultCountOutputTypeSelect = {
    tags?: boolean
    productsProduct?: boolean
  }

  export type ProductsProductResultCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductsProductResultCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsProductResultCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductsProductResultCountOutputTypeArgs)
    ? ProductsProductResultCountOutputType 
    : S extends { select: any } & (ProductsProductResultCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductsProductResultCountOutputType ? ProductsProductResultCountOutputType[P] : never
  } 
      : ProductsProductResultCountOutputType




  // Custom InputTypes

  /**
   * ProductsProductResultCountOutputType without action
   */
  export type ProductsProductResultCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResultCountOutputType
     * 
    **/
    select?: ProductsProductResultCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    products: number
  }

  export type OrderCountOutputTypeSelect = {
    products?: boolean
  }

  export type OrderCountOutputTypeGetPayload<S extends boolean | null | undefined | OrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrderCountOutputTypeArgs)
    ? OrderCountOutputType 
    : S extends { select: any } & (OrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
      : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type AuthorProductCountOutputType
   */


  export type AuthorProductCountOutputType = {
    ProductsProductResult: number
  }

  export type AuthorProductCountOutputTypeSelect = {
    ProductsProductResult?: boolean
  }

  export type AuthorProductCountOutputTypeGetPayload<S extends boolean | null | undefined | AuthorProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AuthorProductCountOutputTypeArgs)
    ? AuthorProductCountOutputType 
    : S extends { select: any } & (AuthorProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AuthorProductCountOutputType ? AuthorProductCountOutputType[P] : never
  } 
      : AuthorProductCountOutputType




  // Custom InputTypes

  /**
   * AuthorProductCountOutputType without action
   */
  export type AuthorProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AuthorProductCountOutputType
     * 
    **/
    select?: AuthorProductCountOutputTypeSelect | null
  }



  /**
   * Count Type TagsCountOutputType
   */


  export type TagsCountOutputType = {
    ProductsProductResult: number
  }

  export type TagsCountOutputTypeSelect = {
    ProductsProductResult?: boolean
  }

  export type TagsCountOutputTypeGetPayload<S extends boolean | null | undefined | TagsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TagsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TagsCountOutputTypeArgs)
    ? TagsCountOutputType 
    : S extends { select: any } & (TagsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TagsCountOutputType ? TagsCountOutputType[P] : never
  } 
      : TagsCountOutputType




  // Custom InputTypes

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     * 
    **/
    select?: TagsCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    body: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    body: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    body: number
    createdAt: number
    userId: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    body?: true
    createdAt?: true
    userId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    body?: true
    createdAt?: true
    userId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    body?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: number
    body: string
    createdAt: Date
    userId: string
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    body?: boolean
    createdAt?: boolean
    userId?: boolean
    User?: boolean | UserArgs
  }


  export type MessageInclude = {
    User?: boolean | UserArgs
  } 

  export type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Message :
    S extends undefined ? never :
    S extends { include: any } & (MessageArgs | MessageFindManyArgs)
    ? Message  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessageArgs | MessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof Message ? Message[P] : never
  } 
      : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): PrismaPromise<Array<MessageGetPayload<T>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Message base type for findUnique actions
   */
  export type MessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUnique
   */
  export interface MessageFindUniqueArgs extends MessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message base type for findFirst actions
   */
  export type MessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * Message findFirst
   */
  export interface MessageFindFirstArgs extends MessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     * 
    **/
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     * 
    **/
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    compoundId: string | null
    userId: string | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    compoundId: string | null
    userId: string | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    compoundId: number
    userId: number
    providerType: number
    providerId: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    accessTokenExpires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: number
    compoundId: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    compoundId?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type AccountInclude = {
    user?: boolean | UserArgs
  } 

  export type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Account :
    S extends undefined ? never :
    S extends { include: any } & (AccountArgs | AccountFindManyArgs)
    ? Account  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AccountArgs | AccountFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Account ? Account[P] : never
  } 
      : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): PrismaPromise<Array<AccountGetPayload<T>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expires: number
    sessionToken: number
    accessToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: number
    userId: string
    expires: Date
    sessionToken: string
    accessToken: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type SessionInclude = {
    user?: boolean | UserArgs
  } 

  export type SessionGetPayload<S extends boolean | null | undefined | SessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Session :
    S extends undefined ? never :
    S extends { include: any } & (SessionArgs | SessionFindManyArgs)
    ? Session  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SessionArgs | SessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Session ? Session[P] : never
  } 
      : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): PrismaPromise<Array<SessionGetPayload<T>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     * 
    **/
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     * 
    **/
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    addressId: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    addressId: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    addressId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: number
    name: string
    addressId: number | null
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    name?: boolean
    addressId?: boolean
    Address?: boolean | AddressArgs
  }


  export type CityInclude = {
    Address?: boolean | AddressArgs
  } 

  export type CityGetPayload<S extends boolean | null | undefined | CityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? City :
    S extends undefined ? never :
    S extends { include: any } & (CityArgs | CityFindManyArgs)
    ? City  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Address' ? AddressGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CityArgs | CityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Address' ? AddressGetPayload<S['select'][P]> | null :  P extends keyof City ? City[P] : never
  } 
      : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? Prisma__CityClient<CityGetPayload<T>> : Prisma__CityClient<CityGetPayload<T> | null, null>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? Prisma__CityClient<CityGetPayload<T>> : Prisma__CityClient<CityGetPayload<T> | null, null>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): PrismaPromise<Array<CityGetPayload<T>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): Prisma__CityClient<CityGetPayload<T>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * City base type for findUnique actions
   */
  export type CityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }

  /**
   * City findUnique
   */
  export interface CityFindUniqueArgs extends CityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City base type for findFirst actions
   */
  export type CityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * City findFirst
   */
  export interface CityFindFirstArgs extends CityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     * 
    **/
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     * 
    **/
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    zip: number | null
    deliveryId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    zip: number | null
    deliveryId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    zip: number | null
    deliveryId: number | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    zip: number | null
    deliveryId: number | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    zip: number
    deliveryId: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    zip?: true
    deliveryId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    zip?: true
    deliveryId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    zip?: true
    deliveryId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    zip?: true
    deliveryId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    zip?: true
    deliveryId?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: number
    zip: number
    deliveryId: number | null
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    zip?: boolean
    deliveryId?: boolean
    Delivery?: boolean | DeliveryArgs
    city?: boolean | Address$cityArgs
    _count?: boolean | AddressCountOutputTypeArgs
  }


  export type AddressInclude = {
    Delivery?: boolean | DeliveryArgs
    city?: boolean | Address$cityArgs
    _count?: boolean | AddressCountOutputTypeArgs
  } 

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs | AddressFindManyArgs)
    ? Address  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Delivery' ? DeliveryGetPayload<S['include'][P]> | null :
        P extends 'city' ? Array < CityGetPayload<S['include'][P]>>  :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AddressArgs | AddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Delivery' ? DeliveryGetPayload<S['select'][P]> | null :
        P extends 'city' ? Array < CityGetPayload<S['select'][P]>>  :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
      : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): PrismaPromise<Array<AddressGetPayload<T>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Delivery<T extends DeliveryArgs= {}>(args?: Subset<T, DeliveryArgs>): Prisma__DeliveryClient<DeliveryGetPayload<T> | Null>;

    city<T extends Address$cityArgs= {}>(args?: Subset<T, Address$cityArgs>): PrismaPromise<Array<CityGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address.city
   */
  export type Address$cityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    productId: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    productId: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    productId: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    productId?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    productId: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    productId?: boolean
    products?: boolean | Category$productsArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }


  export type CategoryInclude = {
    products?: boolean | Category$productsArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  } 

  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends Category$productsArgs= {}>(args?: Subset<T, Category$productsArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category.products
   */
  export type Category$productsArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type ProductSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    sku: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    sku: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    sku: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ProductSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sku?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sku?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    sku?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    sku?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    categories?: boolean | Product$categoriesArgs
    orders?: boolean | Product$ordersArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type ProductInclude = {
    user?: boolean | UserArgs
    categories?: boolean | Product$categoriesArgs
    orders?: boolean | Product$ordersArgs
    _count?: boolean | ProductCountOutputTypeArgs
  } 

  export type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Product :
    S extends undefined ? never :
    S extends { include: any } & (ProductArgs | ProductFindManyArgs)
    ? Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'categories' ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductArgs | ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'categories' ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
      : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): PrismaPromise<Array<ProductGetPayload<T>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    categories<T extends Product$categoriesArgs= {}>(args?: Subset<T, Product$categoriesArgs>): PrismaPromise<Array<CategoryGetPayload<T>>| Null>;

    orders<T extends Product$ordersArgs= {}>(args?: Subset<T, Product$ordersArgs>): PrismaPromise<Array<OrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product.categories
   */
  export type Product$categoriesArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Product.orders
   */
  export type Product$ordersArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Delivery
   */


  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    id: number | null
  }

  export type DeliverySumAggregateOutputType = {
    id: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    id?: true
  }

  export type DeliverySumAggregateInputType = {
    id?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type DeliveryAggregateArgs = {
    /**
     * Filter which Delivery to aggregate.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs = {
    where?: DeliveryWhereInput
    orderBy?: Enumerable<DeliveryOrderByWithAggregationInput>
    by: Array<DeliveryScalarFieldEnum>
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }


  export type DeliveryGroupByOutputType = {
    id: number
    title: string
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect = {
    id?: boolean
    title?: boolean
    address?: boolean | Delivery$addressArgs
    orders?: boolean | Delivery$ordersArgs
    _count?: boolean | DeliveryCountOutputTypeArgs
  }


  export type DeliveryInclude = {
    address?: boolean | Delivery$addressArgs
    orders?: boolean | Delivery$ordersArgs
    _count?: boolean | DeliveryCountOutputTypeArgs
  } 

  export type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Delivery :
    S extends undefined ? never :
    S extends { include: any } & (DeliveryArgs | DeliveryFindManyArgs)
    ? Delivery  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? DeliveryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DeliveryArgs | DeliveryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? DeliveryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Delivery ? Delivery[P] : never
  } 
      : Delivery


  type DeliveryCountArgs = Merge<
    Omit<DeliveryFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryCountAggregateInputType | true
    }
  >

  export interface DeliveryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeliveryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Delivery'> extends True ? Prisma__DeliveryClient<DeliveryGetPayload<T>> : Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>

    /**
     * Find one Delivery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindUniqueOrThrowArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeliveryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Delivery'> extends True ? Prisma__DeliveryClient<DeliveryGetPayload<T>> : Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>

    /**
     * Find the first Delivery that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryFindManyArgs>(
      args?: SelectSubset<T, DeliveryFindManyArgs>
    ): PrismaPromise<Array<DeliveryGetPayload<T>>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
    **/
    create<T extends DeliveryCreateArgs>(
      args: SelectSubset<T, DeliveryCreateArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Create many Deliveries.
     *     @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     *     @example
     *     // Create many Deliveries
     *     const delivery = await prisma.delivery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryCreateManyArgs>(
      args?: SelectSubset<T, DeliveryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryDeleteArgs>(
      args: SelectSubset<T, DeliveryDeleteArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryUpdateArgs>(
      args: SelectSubset<T, DeliveryUpdateArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryDeleteManyArgs>(
      args?: SelectSubset<T, DeliveryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryUpdateManyArgs>(
      args: SelectSubset<T, DeliveryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryUpsertArgs>(
      args: SelectSubset<T, DeliveryUpsertArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeliveryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends Delivery$addressArgs= {}>(args?: Subset<T, Delivery$addressArgs>): PrismaPromise<Array<AddressGetPayload<T>>| Null>;

    orders<T extends Delivery$ordersArgs= {}>(args?: Subset<T, Delivery$ordersArgs>): PrismaPromise<Array<OrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Delivery base type for findUnique actions
   */
  export type DeliveryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUnique
   */
  export interface DeliveryFindUniqueArgs extends DeliveryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery base type for findFirst actions
   */
  export type DeliveryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     * 
    **/
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }

  /**
   * Delivery findFirst
   */
  export interface DeliveryFindFirstArgs extends DeliveryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     * 
    **/
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Deliveries to fetch.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Delivery create
   */
  export type DeliveryCreateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The data needed to create a Delivery.
     * 
    **/
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }


  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs = {
    /**
     * The data used to create many Deliveries.
     * 
    **/
    data: Enumerable<DeliveryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The data needed to update a Delivery.
     * 
    **/
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs = {
    /**
     * The data used to update Deliveries.
     * 
    **/
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     * 
    **/
    where?: DeliveryWhereInput
  }


  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     * 
    **/
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     * 
    **/
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }


  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter which Delivery to delete.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs = {
    /**
     * Filter which Deliveries to delete
     * 
    **/
    where?: DeliveryWhereInput
  }


  /**
   * Delivery.address
   */
  export type Delivery$addressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Delivery.orders
   */
  export type Delivery$ordersArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Delivery without action
   */
  export type DeliveryArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
  }



  /**
   * Model VerificationRequest
   */


  export type AggregateVerificationRequest = {
    _count: VerificationRequestCountAggregateOutputType | null
    _avg: VerificationRequestAvgAggregateOutputType | null
    _sum: VerificationRequestSumAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  export type VerificationRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type VerificationRequestSumAggregateOutputType = {
    id: number | null
  }

  export type VerificationRequestMinAggregateOutputType = {
    id: number | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type VerificationRequestMaxAggregateOutputType = {
    id: number | null
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type VerificationRequestCountAggregateOutputType = {
    id: number
    identifier: number
    token: number
    expires: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type VerificationRequestAvgAggregateInputType = {
    id?: true
  }

  export type VerificationRequestSumAggregateInputType = {
    id?: true
  }

  export type VerificationRequestMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type VerificationRequestMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type VerificationRequestCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type VerificationRequestAggregateArgs = {
    /**
     * Filter which VerificationRequest to aggregate.
     * 
    **/
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationRequests
    **/
    _count?: true | VerificationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationRequestMaxAggregateInputType
  }

  export type GetVerificationRequestAggregateType<T extends VerificationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationRequest[P]>
      : GetScalarType<T[P], AggregateVerificationRequest[P]>
  }




  export type VerificationRequestGroupByArgs = {
    where?: VerificationRequestWhereInput
    orderBy?: Enumerable<VerificationRequestOrderByWithAggregationInput>
    by: Array<VerificationRequestScalarFieldEnum>
    having?: VerificationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationRequestCountAggregateInputType | true
    _avg?: VerificationRequestAvgAggregateInputType
    _sum?: VerificationRequestSumAggregateInputType
    _min?: VerificationRequestMinAggregateInputType
    _max?: VerificationRequestMaxAggregateInputType
  }


  export type VerificationRequestGroupByOutputType = {
    id: number
    identifier: string
    token: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: VerificationRequestCountAggregateOutputType | null
    _avg: VerificationRequestAvgAggregateOutputType | null
    _sum: VerificationRequestSumAggregateOutputType | null
    _min: VerificationRequestMinAggregateOutputType | null
    _max: VerificationRequestMaxAggregateOutputType | null
  }

  type GetVerificationRequestGroupByPayload<T extends VerificationRequestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VerificationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationRequestGroupByOutputType[P]>
        }
      >
    >


  export type VerificationRequestSelect = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    userVerification?: boolean | UserArgs
  }


  export type VerificationRequestInclude = {
    userVerification?: boolean | UserArgs
  } 

  export type VerificationRequestGetPayload<S extends boolean | null | undefined | VerificationRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VerificationRequest :
    S extends undefined ? never :
    S extends { include: any } & (VerificationRequestArgs | VerificationRequestFindManyArgs)
    ? VerificationRequest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userVerification' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VerificationRequestArgs | VerificationRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userVerification' ? UserGetPayload<S['select'][P]> :  P extends keyof VerificationRequest ? VerificationRequest[P] : never
  } 
      : VerificationRequest


  type VerificationRequestCountArgs = Merge<
    Omit<VerificationRequestFindManyArgs, 'select' | 'include'> & {
      select?: VerificationRequestCountAggregateInputType | true
    }
  >

  export interface VerificationRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one VerificationRequest that matches the filter.
     * @param {VerificationRequestFindUniqueArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationRequest'> extends True ? Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>> : Prisma__VerificationRequestClient<VerificationRequestGetPayload<T> | null, null>

    /**
     * Find one VerificationRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationRequestFindUniqueOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VerificationRequestFindUniqueOrThrowArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Find the first VerificationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationRequest'> extends True ? Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>> : Prisma__VerificationRequestClient<VerificationRequestGetPayload<T> | null, null>

    /**
     * Find the first VerificationRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindFirstOrThrowArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationRequestFindFirstOrThrowArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Find zero or more VerificationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany()
     * 
     * // Get first 10 VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VerificationRequestFindManyArgs>(
      args?: SelectSubset<T, VerificationRequestFindManyArgs>
    ): PrismaPromise<Array<VerificationRequestGetPayload<T>>>

    /**
     * Create a VerificationRequest.
     * @param {VerificationRequestCreateArgs} args - Arguments to create a VerificationRequest.
     * @example
     * // Create one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.create({
     *   data: {
     *     // ... data to create a VerificationRequest
     *   }
     * })
     * 
    **/
    create<T extends VerificationRequestCreateArgs>(
      args: SelectSubset<T, VerificationRequestCreateArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Create many VerificationRequests.
     *     @param {VerificationRequestCreateManyArgs} args - Arguments to create many VerificationRequests.
     *     @example
     *     // Create many VerificationRequests
     *     const verificationRequest = await prisma.verificationRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationRequestCreateManyArgs>(
      args?: SelectSubset<T, VerificationRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationRequest.
     * @param {VerificationRequestDeleteArgs} args - Arguments to delete one VerificationRequest.
     * @example
     * // Delete one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.delete({
     *   where: {
     *     // ... filter to delete one VerificationRequest
     *   }
     * })
     * 
    **/
    delete<T extends VerificationRequestDeleteArgs>(
      args: SelectSubset<T, VerificationRequestDeleteArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Update one VerificationRequest.
     * @param {VerificationRequestUpdateArgs} args - Arguments to update one VerificationRequest.
     * @example
     * // Update one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationRequestUpdateArgs>(
      args: SelectSubset<T, VerificationRequestUpdateArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Delete zero or more VerificationRequests.
     * @param {VerificationRequestDeleteManyArgs} args - Arguments to filter VerificationRequests to delete.
     * @example
     * // Delete a few VerificationRequests
     * const { count } = await prisma.verificationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationRequestDeleteManyArgs>(
      args?: SelectSubset<T, VerificationRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationRequestUpdateManyArgs>(
      args: SelectSubset<T, VerificationRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationRequest.
     * @param {VerificationRequestUpsertArgs} args - Arguments to update or create a VerificationRequest.
     * @example
     * // Update or create a VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.upsert({
     *   create: {
     *     // ... data to create a VerificationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationRequest we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationRequestUpsertArgs>(
      args: SelectSubset<T, VerificationRequestUpsertArgs>
    ): Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>

    /**
     * Count the number of VerificationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestCountArgs} args - Arguments to filter VerificationRequests to count.
     * @example
     * // Count the number of VerificationRequests
     * const count = await prisma.verificationRequest.count({
     *   where: {
     *     // ... the filter for the VerificationRequests we want to count
     *   }
     * })
    **/
    count<T extends VerificationRequestCountArgs>(
      args?: Subset<T, VerificationRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationRequestAggregateArgs>(args: Subset<T, VerificationRequestAggregateArgs>): PrismaPromise<GetVerificationRequestAggregateType<T>>

    /**
     * Group by VerificationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationRequestGroupByArgs['orderBy'] }
        : { orderBy?: VerificationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationRequestGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationRequestClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    userVerification<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VerificationRequest base type for findUnique actions
   */
  export type VerificationRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter, which VerificationRequest to fetch.
     * 
    **/
    where: VerificationRequestWhereUniqueInput
  }

  /**
   * VerificationRequest findUnique
   */
  export interface VerificationRequestFindUniqueArgs extends VerificationRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationRequest findUniqueOrThrow
   */
  export type VerificationRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter, which VerificationRequest to fetch.
     * 
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest base type for findFirst actions
   */
  export type VerificationRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter, which VerificationRequest to fetch.
     * 
    **/
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     * 
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     * 
    **/
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }

  /**
   * VerificationRequest findFirst
   */
  export interface VerificationRequestFindFirstArgs extends VerificationRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationRequest findFirstOrThrow
   */
  export type VerificationRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter, which VerificationRequest to fetch.
     * 
    **/
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
     * 
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationRequests.
     * 
    **/
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }


  /**
   * VerificationRequest findMany
   */
  export type VerificationRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter, which VerificationRequests to fetch.
     * 
    **/
    where?: VerificationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationRequests.
     * 
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }


  /**
   * VerificationRequest create
   */
  export type VerificationRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * The data needed to create a VerificationRequest.
     * 
    **/
    data: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
  }


  /**
   * VerificationRequest createMany
   */
  export type VerificationRequestCreateManyArgs = {
    /**
     * The data used to create many VerificationRequests.
     * 
    **/
    data: Enumerable<VerificationRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationRequest update
   */
  export type VerificationRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * The data needed to update a VerificationRequest.
     * 
    **/
    data: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
    /**
     * Choose, which VerificationRequest to update.
     * 
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest updateMany
   */
  export type VerificationRequestUpdateManyArgs = {
    /**
     * The data used to update VerificationRequests.
     * 
    **/
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyInput>
    /**
     * Filter which VerificationRequests to update
     * 
    **/
    where?: VerificationRequestWhereInput
  }


  /**
   * VerificationRequest upsert
   */
  export type VerificationRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * The filter to search for the VerificationRequest to update in case it exists.
     * 
    **/
    where: VerificationRequestWhereUniqueInput
    /**
     * In case the VerificationRequest found by the `where` argument doesn't exist, create a new VerificationRequest with this data.
     * 
    **/
    create: XOR<VerificationRequestCreateInput, VerificationRequestUncheckedCreateInput>
    /**
     * In case the VerificationRequest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerificationRequestUpdateInput, VerificationRequestUncheckedUpdateInput>
  }


  /**
   * VerificationRequest delete
   */
  export type VerificationRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    /**
     * Filter which VerificationRequest to delete.
     * 
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest deleteMany
   */
  export type VerificationRequestDeleteManyArgs = {
    /**
     * Filter which VerificationRequests to delete
     * 
    **/
    where?: VerificationRequestWhereInput
  }


  /**
   * VerificationRequest without action
   */
  export type VerificationRequestArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
  }



  /**
   * Model product_category
   */


  export type AggregateProduct_category = {
    _count: Product_categoryCountAggregateOutputType | null
    _avg: Product_categoryAvgAggregateOutputType | null
    _sum: Product_categorySumAggregateOutputType | null
    _min: Product_categoryMinAggregateOutputType | null
    _max: Product_categoryMaxAggregateOutputType | null
  }

  export type Product_categoryAvgAggregateOutputType = {
    id: number | null
  }

  export type Product_categorySumAggregateOutputType = {
    id: number | null
  }

  export type Product_categoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Product_categoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Product_categoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Product_categoryAvgAggregateInputType = {
    id?: true
  }

  export type Product_categorySumAggregateInputType = {
    id?: true
  }

  export type Product_categoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Product_categoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Product_categoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Product_categoryAggregateArgs = {
    /**
     * Filter which product_category to aggregate.
     * 
    **/
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_categories
    **/
    _count?: true | Product_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_categoryMaxAggregateInputType
  }

  export type GetProduct_categoryAggregateType<T extends Product_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_category[P]>
      : GetScalarType<T[P], AggregateProduct_category[P]>
  }




  export type Product_categoryGroupByArgs = {
    where?: product_categoryWhereInput
    orderBy?: Enumerable<product_categoryOrderByWithAggregationInput>
    by: Array<Product_categoryScalarFieldEnum>
    having?: product_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_categoryCountAggregateInputType | true
    _avg?: Product_categoryAvgAggregateInputType
    _sum?: Product_categorySumAggregateInputType
    _min?: Product_categoryMinAggregateInputType
    _max?: Product_categoryMaxAggregateInputType
  }


  export type Product_categoryGroupByOutputType = {
    id: number
    name: string
    _count: Product_categoryCountAggregateOutputType | null
    _avg: Product_categoryAvgAggregateOutputType | null
    _sum: Product_categorySumAggregateOutputType | null
    _min: Product_categoryMinAggregateOutputType | null
    _max: Product_categoryMaxAggregateOutputType | null
  }

  type GetProduct_categoryGroupByPayload<T extends Product_categoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Product_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Product_categoryGroupByOutputType[P]>
        }
      >
    >


  export type product_categorySelect = {
    id?: boolean
    name?: boolean
  }


  export type product_categoryGetPayload<S extends boolean | null | undefined | product_categoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? product_category :
    S extends undefined ? never :
    S extends { include: any } & (product_categoryArgs | product_categoryFindManyArgs)
    ? product_category 
    : S extends { select: any } & (product_categoryArgs | product_categoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof product_category ? product_category[P] : never
  } 
      : product_category


  type product_categoryCountArgs = Merge<
    Omit<product_categoryFindManyArgs, 'select' | 'include'> & {
      select?: Product_categoryCountAggregateInputType | true
    }
  >

  export interface product_categoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Product_category that matches the filter.
     * @param {product_categoryFindUniqueArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_categoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, product_categoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'product_category'> extends True ? Prisma__product_categoryClient<product_categoryGetPayload<T>> : Prisma__product_categoryClient<product_categoryGetPayload<T> | null, null>

    /**
     * Find one Product_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_categoryFindUniqueOrThrowArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_categoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, product_categoryFindUniqueOrThrowArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Find the first Product_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindFirstArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_categoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, product_categoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'product_category'> extends True ? Prisma__product_categoryClient<product_categoryGetPayload<T>> : Prisma__product_categoryClient<product_categoryGetPayload<T> | null, null>

    /**
     * Find the first Product_category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindFirstOrThrowArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_categoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, product_categoryFindFirstOrThrowArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Find zero or more Product_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_categories
     * const product_categories = await prisma.product_category.findMany()
     * 
     * // Get first 10 Product_categories
     * const product_categories = await prisma.product_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_categoryWithIdOnly = await prisma.product_category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_categoryFindManyArgs>(
      args?: SelectSubset<T, product_categoryFindManyArgs>
    ): PrismaPromise<Array<product_categoryGetPayload<T>>>

    /**
     * Create a Product_category.
     * @param {product_categoryCreateArgs} args - Arguments to create a Product_category.
     * @example
     * // Create one Product_category
     * const Product_category = await prisma.product_category.create({
     *   data: {
     *     // ... data to create a Product_category
     *   }
     * })
     * 
    **/
    create<T extends product_categoryCreateArgs>(
      args: SelectSubset<T, product_categoryCreateArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Create many Product_categories.
     *     @param {product_categoryCreateManyArgs} args - Arguments to create many Product_categories.
     *     @example
     *     // Create many Product_categories
     *     const product_category = await prisma.product_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_categoryCreateManyArgs>(
      args?: SelectSubset<T, product_categoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product_category.
     * @param {product_categoryDeleteArgs} args - Arguments to delete one Product_category.
     * @example
     * // Delete one Product_category
     * const Product_category = await prisma.product_category.delete({
     *   where: {
     *     // ... filter to delete one Product_category
     *   }
     * })
     * 
    **/
    delete<T extends product_categoryDeleteArgs>(
      args: SelectSubset<T, product_categoryDeleteArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Update one Product_category.
     * @param {product_categoryUpdateArgs} args - Arguments to update one Product_category.
     * @example
     * // Update one Product_category
     * const product_category = await prisma.product_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_categoryUpdateArgs>(
      args: SelectSubset<T, product_categoryUpdateArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Delete zero or more Product_categories.
     * @param {product_categoryDeleteManyArgs} args - Arguments to filter Product_categories to delete.
     * @example
     * // Delete a few Product_categories
     * const { count } = await prisma.product_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_categoryDeleteManyArgs>(
      args?: SelectSubset<T, product_categoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_categories
     * const product_category = await prisma.product_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_categoryUpdateManyArgs>(
      args: SelectSubset<T, product_categoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_category.
     * @param {product_categoryUpsertArgs} args - Arguments to update or create a Product_category.
     * @example
     * // Update or create a Product_category
     * const product_category = await prisma.product_category.upsert({
     *   create: {
     *     // ... data to create a Product_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_category we want to update
     *   }
     * })
    **/
    upsert<T extends product_categoryUpsertArgs>(
      args: SelectSubset<T, product_categoryUpsertArgs>
    ): Prisma__product_categoryClient<product_categoryGetPayload<T>>

    /**
     * Count the number of Product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryCountArgs} args - Arguments to filter Product_categories to count.
     * @example
     * // Count the number of Product_categories
     * const count = await prisma.product_category.count({
     *   where: {
     *     // ... the filter for the Product_categories we want to count
     *   }
     * })
    **/
    count<T extends product_categoryCountArgs>(
      args?: Subset<T, product_categoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_categoryAggregateArgs>(args: Subset<T, Product_categoryAggregateArgs>): PrismaPromise<GetProduct_categoryAggregateType<T>>

    /**
     * Group by Product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Product_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Product_categoryGroupByArgs['orderBy'] }
        : { orderBy?: Product_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Product_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_categoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for product_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__product_categoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * product_category base type for findUnique actions
   */
  export type product_categoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter, which product_category to fetch.
     * 
    **/
    where: product_categoryWhereUniqueInput
  }

  /**
   * product_category findUnique
   */
  export interface product_categoryFindUniqueArgs extends product_categoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product_category findUniqueOrThrow
   */
  export type product_categoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter, which product_category to fetch.
     * 
    **/
    where: product_categoryWhereUniqueInput
  }


  /**
   * product_category base type for findFirst actions
   */
  export type product_categoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter, which product_category to fetch.
     * 
    **/
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_categories.
     * 
    **/
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_categories.
     * 
    **/
    distinct?: Enumerable<Product_categoryScalarFieldEnum>
  }

  /**
   * product_category findFirst
   */
  export interface product_categoryFindFirstArgs extends product_categoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product_category findFirstOrThrow
   */
  export type product_categoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter, which product_category to fetch.
     * 
    **/
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_categories.
     * 
    **/
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_categories.
     * 
    **/
    distinct?: Enumerable<Product_categoryScalarFieldEnum>
  }


  /**
   * product_category findMany
   */
  export type product_categoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter, which product_categories to fetch.
     * 
    **/
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_categories.
     * 
    **/
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Product_categoryScalarFieldEnum>
  }


  /**
   * product_category create
   */
  export type product_categoryCreateArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * The data needed to create a product_category.
     * 
    **/
    data: XOR<product_categoryCreateInput, product_categoryUncheckedCreateInput>
  }


  /**
   * product_category createMany
   */
  export type product_categoryCreateManyArgs = {
    /**
     * The data used to create many product_categories.
     * 
    **/
    data: Enumerable<product_categoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * product_category update
   */
  export type product_categoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * The data needed to update a product_category.
     * 
    **/
    data: XOR<product_categoryUpdateInput, product_categoryUncheckedUpdateInput>
    /**
     * Choose, which product_category to update.
     * 
    **/
    where: product_categoryWhereUniqueInput
  }


  /**
   * product_category updateMany
   */
  export type product_categoryUpdateManyArgs = {
    /**
     * The data used to update product_categories.
     * 
    **/
    data: XOR<product_categoryUpdateManyMutationInput, product_categoryUncheckedUpdateManyInput>
    /**
     * Filter which product_categories to update
     * 
    **/
    where?: product_categoryWhereInput
  }


  /**
   * product_category upsert
   */
  export type product_categoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * The filter to search for the product_category to update in case it exists.
     * 
    **/
    where: product_categoryWhereUniqueInput
    /**
     * In case the product_category found by the `where` argument doesn't exist, create a new product_category with this data.
     * 
    **/
    create: XOR<product_categoryCreateInput, product_categoryUncheckedCreateInput>
    /**
     * In case the product_category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<product_categoryUpdateInput, product_categoryUncheckedUpdateInput>
  }


  /**
   * product_category delete
   */
  export type product_categoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
    /**
     * Filter which product_category to delete.
     * 
    **/
    where: product_categoryWhereUniqueInput
  }


  /**
   * product_category deleteMany
   */
  export type product_categoryDeleteManyArgs = {
    /**
     * Filter which product_categories to delete
     * 
    **/
    where?: product_categoryWhereInput
  }


  /**
   * product_category without action
   */
  export type product_categoryArgs = {
    /**
     * Select specific fields to fetch from the product_category
     * 
    **/
    select?: product_categorySelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    first_name: string | null
    last_name: string | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    auth_is_telegram: boolean | null
    auth_is_yandex: boolean | null
    auth_is_google: boolean | null
    role: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailDateVerified: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    first_name: string | null
    last_name: string | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    auth_is_telegram: boolean | null
    auth_is_yandex: boolean | null
    auth_is_google: boolean | null
    role: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailDateVerified: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    first_name: number
    last_name: number
    phone_user: number
    trademark: number
    locale_user: number
    image_url_user: number
    auth_is_telegram: number
    auth_is_yandex: number
    auth_is_google: number
    role: number
    bio: number
    createdAt: number
    updatedAt: number
    emailDateVerified: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    first_name?: true
    last_name?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    role?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    emailDateVerified?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    first_name?: true
    last_name?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    role?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    emailDateVerified?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    first_name?: true
    last_name?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    role?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    emailDateVerified?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string | null
    first_name: string | null
    last_name: string | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    role: string
    bio: string | null
    createdAt: Date
    updatedAt: Date
    emailDateVerified: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_user?: boolean
    trademark?: boolean
    locale_user?: boolean
    image_url_user?: boolean
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailDateVerified?: boolean
    messages?: boolean | User$messagesArgs
    orders?: boolean | User$ordersArgs
    products?: boolean | User$productsArgs
    verifiedUsers?: boolean | User$verifiedUsersArgs
    accounts?: boolean | User$accountsArgs
    sessions?: boolean | User$sessionsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    messages?: boolean | User$messagesArgs
    orders?: boolean | User$ordersArgs
    products?: boolean | User$productsArgs
    verifiedUsers?: boolean | User$verifiedUsersArgs
    accounts?: boolean | User$accountsArgs
    sessions?: boolean | User$sessionsArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'messages' ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'verifiedUsers' ? Array < VerificationRequestGetPayload<S['include'][P]>>  :
        P extends 'accounts' ? Array < AccountGetPayload<S['include'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'messages' ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'verifiedUsers' ? Array < VerificationRequestGetPayload<S['select'][P]>>  :
        P extends 'accounts' ? Array < AccountGetPayload<S['select'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    messages<T extends User$messagesArgs= {}>(args?: Subset<T, User$messagesArgs>): PrismaPromise<Array<MessageGetPayload<T>>| Null>;

    orders<T extends User$ordersArgs= {}>(args?: Subset<T, User$ordersArgs>): PrismaPromise<Array<OrderGetPayload<T>>| Null>;

    products<T extends User$productsArgs= {}>(args?: Subset<T, User$productsArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    verifiedUsers<T extends User$verifiedUsersArgs= {}>(args?: Subset<T, User$verifiedUsersArgs>): PrismaPromise<Array<VerificationRequestGetPayload<T>>| Null>;

    accounts<T extends User$accountsArgs= {}>(args?: Subset<T, User$accountsArgs>): PrismaPromise<Array<AccountGetPayload<T>>| Null>;

    sessions<T extends User$sessionsArgs= {}>(args?: Subset<T, User$sessionsArgs>): PrismaPromise<Array<SessionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User.messages
   */
  export type User$messagesArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * User.orders
   */
  export type User$ordersArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * User.products
   */
  export type User$productsArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * User.verifiedUsers
   */
  export type User$verifiedUsersArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
     * 
    **/
    select?: VerificationRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerificationRequestInclude | null
    where?: VerificationRequestWhereInput
    orderBy?: Enumerable<VerificationRequestOrderByWithRelationInput>
    cursor?: VerificationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model ProductsProduct
   */


  export type AggregateProductsProduct = {
    _count: ProductsProductCountAggregateOutputType | null
    _avg: ProductsProductAvgAggregateOutputType | null
    _sum: ProductsProductSumAggregateOutputType | null
    _min: ProductsProductMinAggregateOutputType | null
    _max: ProductsProductMaxAggregateOutputType | null
  }

  export type ProductsProductAvgAggregateOutputType = {
    count: number | null
    next: number | null
    previous: number | null
  }

  export type ProductsProductSumAggregateOutputType = {
    count: number | null
    next: number | null
    previous: number | null
  }

  export type ProductsProductMinAggregateOutputType = {
    id: string | null
    count: number | null
    next: number | null
    previous: number | null
  }

  export type ProductsProductMaxAggregateOutputType = {
    id: string | null
    count: number | null
    next: number | null
    previous: number | null
  }

  export type ProductsProductCountAggregateOutputType = {
    id: number
    count: number
    next: number
    previous: number
    _all: number
  }


  export type ProductsProductAvgAggregateInputType = {
    count?: true
    next?: true
    previous?: true
  }

  export type ProductsProductSumAggregateInputType = {
    count?: true
    next?: true
    previous?: true
  }

  export type ProductsProductMinAggregateInputType = {
    id?: true
    count?: true
    next?: true
    previous?: true
  }

  export type ProductsProductMaxAggregateInputType = {
    id?: true
    count?: true
    next?: true
    previous?: true
  }

  export type ProductsProductCountAggregateInputType = {
    id?: true
    count?: true
    next?: true
    previous?: true
    _all?: true
  }

  export type ProductsProductAggregateArgs = {
    /**
     * Filter which ProductsProduct to aggregate.
     * 
    **/
    where?: ProductsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductsProducts
    **/
    _count?: true | ProductsProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsProductMaxAggregateInputType
  }

  export type GetProductsProductAggregateType<T extends ProductsProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProductsProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductsProduct[P]>
      : GetScalarType<T[P], AggregateProductsProduct[P]>
  }




  export type ProductsProductGroupByArgs = {
    where?: ProductsProductWhereInput
    orderBy?: Enumerable<ProductsProductOrderByWithAggregationInput>
    by: Array<ProductsProductScalarFieldEnum>
    having?: ProductsProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsProductCountAggregateInputType | true
    _avg?: ProductsProductAvgAggregateInputType
    _sum?: ProductsProductSumAggregateInputType
    _min?: ProductsProductMinAggregateInputType
    _max?: ProductsProductMaxAggregateInputType
  }


  export type ProductsProductGroupByOutputType = {
    id: string
    count: number
    next: number
    previous: number
    _count: ProductsProductCountAggregateOutputType | null
    _avg: ProductsProductAvgAggregateOutputType | null
    _sum: ProductsProductSumAggregateOutputType | null
    _min: ProductsProductMinAggregateOutputType | null
    _max: ProductsProductMaxAggregateOutputType | null
  }

  type GetProductsProductGroupByPayload<T extends ProductsProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductsProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductsProductSelect = {
    id?: boolean
    count?: boolean
    next?: boolean
    previous?: boolean
    results?: boolean | ProductsProduct$resultsArgs
    _count?: boolean | ProductsProductCountOutputTypeArgs
  }


  export type ProductsProductInclude = {
    results?: boolean | ProductsProduct$resultsArgs
    _count?: boolean | ProductsProductCountOutputTypeArgs
  } 

  export type ProductsProductGetPayload<S extends boolean | null | undefined | ProductsProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsProduct :
    S extends undefined ? never :
    S extends { include: any } & (ProductsProductArgs | ProductsProductFindManyArgs)
    ? ProductsProduct  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'results' ? Array < ProductsProductResultGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductsProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductsProductArgs | ProductsProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'results' ? Array < ProductsProductResultGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductsProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductsProduct ? ProductsProduct[P] : never
  } 
      : ProductsProduct


  type ProductsProductCountArgs = Merge<
    Omit<ProductsProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductsProductCountAggregateInputType | true
    }
  >

  export interface ProductsProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProductsProduct that matches the filter.
     * @param {ProductsProductFindUniqueArgs} args - Arguments to find a ProductsProduct
     * @example
     * // Get one ProductsProduct
     * const productsProduct = await prisma.productsProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductsProduct'> extends True ? Prisma__ProductsProductClient<ProductsProductGetPayload<T>> : Prisma__ProductsProductClient<ProductsProductGetPayload<T> | null, null>

    /**
     * Find one ProductsProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductsProductFindUniqueOrThrowArgs} args - Arguments to find a ProductsProduct
     * @example
     * // Get one ProductsProduct
     * const productsProduct = await prisma.productsProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductsProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductFindUniqueOrThrowArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Find the first ProductsProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductFindFirstArgs} args - Arguments to find a ProductsProduct
     * @example
     * // Get one ProductsProduct
     * const productsProduct = await prisma.productsProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductsProduct'> extends True ? Prisma__ProductsProductClient<ProductsProductGetPayload<T>> : Prisma__ProductsProductClient<ProductsProductGetPayload<T> | null, null>

    /**
     * Find the first ProductsProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductFindFirstOrThrowArgs} args - Arguments to find a ProductsProduct
     * @example
     * // Get one ProductsProduct
     * const productsProduct = await prisma.productsProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductsProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductFindFirstOrThrowArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Find zero or more ProductsProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductsProducts
     * const productsProducts = await prisma.productsProduct.findMany()
     * 
     * // Get first 10 ProductsProducts
     * const productsProducts = await prisma.productsProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsProductWithIdOnly = await prisma.productsProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsProductFindManyArgs>(
      args?: SelectSubset<T, ProductsProductFindManyArgs>
    ): PrismaPromise<Array<ProductsProductGetPayload<T>>>

    /**
     * Create a ProductsProduct.
     * @param {ProductsProductCreateArgs} args - Arguments to create a ProductsProduct.
     * @example
     * // Create one ProductsProduct
     * const ProductsProduct = await prisma.productsProduct.create({
     *   data: {
     *     // ... data to create a ProductsProduct
     *   }
     * })
     * 
    **/
    create<T extends ProductsProductCreateArgs>(
      args: SelectSubset<T, ProductsProductCreateArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Create many ProductsProducts.
     *     @param {ProductsProductCreateManyArgs} args - Arguments to create many ProductsProducts.
     *     @example
     *     // Create many ProductsProducts
     *     const productsProduct = await prisma.productsProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductsProductCreateManyArgs>(
      args?: SelectSubset<T, ProductsProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductsProduct.
     * @param {ProductsProductDeleteArgs} args - Arguments to delete one ProductsProduct.
     * @example
     * // Delete one ProductsProduct
     * const ProductsProduct = await prisma.productsProduct.delete({
     *   where: {
     *     // ... filter to delete one ProductsProduct
     *   }
     * })
     * 
    **/
    delete<T extends ProductsProductDeleteArgs>(
      args: SelectSubset<T, ProductsProductDeleteArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Update one ProductsProduct.
     * @param {ProductsProductUpdateArgs} args - Arguments to update one ProductsProduct.
     * @example
     * // Update one ProductsProduct
     * const productsProduct = await prisma.productsProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsProductUpdateArgs>(
      args: SelectSubset<T, ProductsProductUpdateArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Delete zero or more ProductsProducts.
     * @param {ProductsProductDeleteManyArgs} args - Arguments to filter ProductsProducts to delete.
     * @example
     * // Delete a few ProductsProducts
     * const { count } = await prisma.productsProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductsProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductsProducts
     * const productsProduct = await prisma.productsProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsProductUpdateManyArgs>(
      args: SelectSubset<T, ProductsProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductsProduct.
     * @param {ProductsProductUpsertArgs} args - Arguments to update or create a ProductsProduct.
     * @example
     * // Update or create a ProductsProduct
     * const productsProduct = await prisma.productsProduct.upsert({
     *   create: {
     *     // ... data to create a ProductsProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductsProduct we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsProductUpsertArgs>(
      args: SelectSubset<T, ProductsProductUpsertArgs>
    ): Prisma__ProductsProductClient<ProductsProductGetPayload<T>>

    /**
     * Count the number of ProductsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductCountArgs} args - Arguments to filter ProductsProducts to count.
     * @example
     * // Count the number of ProductsProducts
     * const count = await prisma.productsProduct.count({
     *   where: {
     *     // ... the filter for the ProductsProducts we want to count
     *   }
     * })
    **/
    count<T extends ProductsProductCountArgs>(
      args?: Subset<T, ProductsProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductsProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsProductAggregateArgs>(args: Subset<T, ProductsProductAggregateArgs>): PrismaPromise<GetProductsProductAggregateType<T>>

    /**
     * Group by ProductsProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductsProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductsProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    results<T extends ProductsProduct$resultsArgs= {}>(args?: Subset<T, ProductsProduct$resultsArgs>): PrismaPromise<Array<ProductsProductResultGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductsProduct base type for findUnique actions
   */
  export type ProductsProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter, which ProductsProduct to fetch.
     * 
    **/
    where: ProductsProductWhereUniqueInput
  }

  /**
   * ProductsProduct findUnique
   */
  export interface ProductsProductFindUniqueArgs extends ProductsProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProduct findUniqueOrThrow
   */
  export type ProductsProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter, which ProductsProduct to fetch.
     * 
    **/
    where: ProductsProductWhereUniqueInput
  }


  /**
   * ProductsProduct base type for findFirst actions
   */
  export type ProductsProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter, which ProductsProduct to fetch.
     * 
    **/
    where?: ProductsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProducts.
     * 
    **/
    cursor?: ProductsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProducts.
     * 
    **/
    distinct?: Enumerable<ProductsProductScalarFieldEnum>
  }

  /**
   * ProductsProduct findFirst
   */
  export interface ProductsProductFindFirstArgs extends ProductsProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProduct findFirstOrThrow
   */
  export type ProductsProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter, which ProductsProduct to fetch.
     * 
    **/
    where?: ProductsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProducts.
     * 
    **/
    cursor?: ProductsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProducts.
     * 
    **/
    distinct?: Enumerable<ProductsProductScalarFieldEnum>
  }


  /**
   * ProductsProduct findMany
   */
  export type ProductsProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter, which ProductsProducts to fetch.
     * 
    **/
    where?: ProductsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductsProducts.
     * 
    **/
    cursor?: ProductsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductsProductScalarFieldEnum>
  }


  /**
   * ProductsProduct create
   */
  export type ProductsProductCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * The data needed to create a ProductsProduct.
     * 
    **/
    data: XOR<ProductsProductCreateInput, ProductsProductUncheckedCreateInput>
  }


  /**
   * ProductsProduct createMany
   */
  export type ProductsProductCreateManyArgs = {
    /**
     * The data used to create many ProductsProducts.
     * 
    **/
    data: Enumerable<ProductsProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductsProduct update
   */
  export type ProductsProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * The data needed to update a ProductsProduct.
     * 
    **/
    data: XOR<ProductsProductUpdateInput, ProductsProductUncheckedUpdateInput>
    /**
     * Choose, which ProductsProduct to update.
     * 
    **/
    where: ProductsProductWhereUniqueInput
  }


  /**
   * ProductsProduct updateMany
   */
  export type ProductsProductUpdateManyArgs = {
    /**
     * The data used to update ProductsProducts.
     * 
    **/
    data: XOR<ProductsProductUpdateManyMutationInput, ProductsProductUncheckedUpdateManyInput>
    /**
     * Filter which ProductsProducts to update
     * 
    **/
    where?: ProductsProductWhereInput
  }


  /**
   * ProductsProduct upsert
   */
  export type ProductsProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * The filter to search for the ProductsProduct to update in case it exists.
     * 
    **/
    where: ProductsProductWhereUniqueInput
    /**
     * In case the ProductsProduct found by the `where` argument doesn't exist, create a new ProductsProduct with this data.
     * 
    **/
    create: XOR<ProductsProductCreateInput, ProductsProductUncheckedCreateInput>
    /**
     * In case the ProductsProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductsProductUpdateInput, ProductsProductUncheckedUpdateInput>
  }


  /**
   * ProductsProduct delete
   */
  export type ProductsProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    /**
     * Filter which ProductsProduct to delete.
     * 
    **/
    where: ProductsProductWhereUniqueInput
  }


  /**
   * ProductsProduct deleteMany
   */
  export type ProductsProductDeleteManyArgs = {
    /**
     * Filter which ProductsProducts to delete
     * 
    **/
    where?: ProductsProductWhereInput
  }


  /**
   * ProductsProduct.results
   */
  export type ProductsProduct$resultsArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    where?: ProductsProductResultWhereInput
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    cursor?: ProductsProductResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }


  /**
   * ProductsProduct without action
   */
  export type ProductsProductArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
  }



  /**
   * Model ProductsProductResult
   */


  export type AggregateProductsProductResult = {
    _count: ProductsProductResultCountAggregateOutputType | null
    _avg: ProductsProductResultAvgAggregateOutputType | null
    _sum: ProductsProductResultSumAggregateOutputType | null
    _min: ProductsProductResultMinAggregateOutputType | null
    _max: ProductsProductResultMaxAggregateOutputType | null
  }

  export type ProductsProductResultAvgAggregateOutputType = {
    price_product: number | null
  }

  export type ProductsProductResultSumAggregateOutputType = {
    price_product: number | null
  }

  export type ProductsProductResultMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    image: string | null
    text: string | null
    price_product: number | null
    taxation: string | null
    tax: string | null
    authorProductId: string | null
    productsProductId: string | null
  }

  export type ProductsProductResultMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    image: string | null
    text: string | null
    price_product: number | null
    taxation: string | null
    tax: string | null
    authorProductId: string | null
    productsProductId: string | null
  }

  export type ProductsProductResultCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    image: number
    text: number
    price_product: number
    taxation: number
    tax: number
    authorProductId: number
    productsProductId: number
    _all: number
  }


  export type ProductsProductResultAvgAggregateInputType = {
    price_product?: true
  }

  export type ProductsProductResultSumAggregateInputType = {
    price_product?: true
  }

  export type ProductsProductResultMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    text?: true
    price_product?: true
    taxation?: true
    tax?: true
    authorProductId?: true
    productsProductId?: true
  }

  export type ProductsProductResultMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    text?: true
    price_product?: true
    taxation?: true
    tax?: true
    authorProductId?: true
    productsProductId?: true
  }

  export type ProductsProductResultCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    text?: true
    price_product?: true
    taxation?: true
    tax?: true
    authorProductId?: true
    productsProductId?: true
    _all?: true
  }

  export type ProductsProductResultAggregateArgs = {
    /**
     * Filter which ProductsProductResult to aggregate.
     * 
    **/
    where?: ProductsProductResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductResults to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductsProductResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductResults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductResults.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductsProductResults
    **/
    _count?: true | ProductsProductResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsProductResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsProductResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsProductResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsProductResultMaxAggregateInputType
  }

  export type GetProductsProductResultAggregateType<T extends ProductsProductResultAggregateArgs> = {
        [P in keyof T & keyof AggregateProductsProductResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductsProductResult[P]>
      : GetScalarType<T[P], AggregateProductsProductResult[P]>
  }




  export type ProductsProductResultGroupByArgs = {
    where?: ProductsProductResultWhereInput
    orderBy?: Enumerable<ProductsProductResultOrderByWithAggregationInput>
    by: Array<ProductsProductResultScalarFieldEnum>
    having?: ProductsProductResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsProductResultCountAggregateInputType | true
    _avg?: ProductsProductResultAvgAggregateInputType
    _sum?: ProductsProductResultSumAggregateInputType
    _min?: ProductsProductResultMinAggregateInputType
    _max?: ProductsProductResultMaxAggregateInputType
  }


  export type ProductsProductResultGroupByOutputType = {
    id: string
    userId: string | null
    name: string | null
    image: string | null
    text: string | null
    price_product: number | null
    taxation: string | null
    tax: string | null
    authorProductId: string | null
    productsProductId: string | null
    _count: ProductsProductResultCountAggregateOutputType | null
    _avg: ProductsProductResultAvgAggregateOutputType | null
    _sum: ProductsProductResultSumAggregateOutputType | null
    _min: ProductsProductResultMinAggregateOutputType | null
    _max: ProductsProductResultMaxAggregateOutputType | null
  }

  type GetProductsProductResultGroupByPayload<T extends ProductsProductResultGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductsProductResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsProductResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsProductResultGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsProductResultGroupByOutputType[P]>
        }
      >
    >


  export type ProductsProductResultSelect = {
    id?: boolean
    tags?: boolean | ProductsProductResult$tagsArgs
    author?: boolean | AuthorProductArgs
    userId?: boolean
    name?: boolean
    image?: boolean
    text?: boolean
    price_product?: boolean
    taxation?: boolean
    tax?: boolean
    authorProductId?: boolean
    productsProductId?: boolean
    productsProduct?: boolean | ProductsProductResult$productsProductArgs
    _count?: boolean | ProductsProductResultCountOutputTypeArgs
  }


  export type ProductsProductResultInclude = {
    tags?: boolean | ProductsProductResult$tagsArgs
    author?: boolean | AuthorProductArgs
    productsProduct?: boolean | ProductsProductResult$productsProductArgs
    _count?: boolean | ProductsProductResultCountOutputTypeArgs
  } 

  export type ProductsProductResultGetPayload<S extends boolean | null | undefined | ProductsProductResultArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsProductResult :
    S extends undefined ? never :
    S extends { include: any } & (ProductsProductResultArgs | ProductsProductResultFindManyArgs)
    ? ProductsProductResult  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tags' ? Array < TagsGetPayload<S['include'][P]>>  :
        P extends 'author' ? AuthorProductGetPayload<S['include'][P]> | null :
        P extends 'productsProduct' ? Array < ProductsProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductsProductResultCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductsProductResultArgs | ProductsProductResultFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tags' ? Array < TagsGetPayload<S['select'][P]>>  :
        P extends 'author' ? AuthorProductGetPayload<S['select'][P]> | null :
        P extends 'productsProduct' ? Array < ProductsProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductsProductResultCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductsProductResult ? ProductsProductResult[P] : never
  } 
      : ProductsProductResult


  type ProductsProductResultCountArgs = Merge<
    Omit<ProductsProductResultFindManyArgs, 'select' | 'include'> & {
      select?: ProductsProductResultCountAggregateInputType | true
    }
  >

  export interface ProductsProductResultDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProductsProductResult that matches the filter.
     * @param {ProductsProductResultFindUniqueArgs} args - Arguments to find a ProductsProductResult
     * @example
     * // Get one ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsProductResultFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsProductResultFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductsProductResult'> extends True ? Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>> : Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T> | null, null>

    /**
     * Find one ProductsProductResult that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductsProductResultFindUniqueOrThrowArgs} args - Arguments to find a ProductsProductResult
     * @example
     * // Get one ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductsProductResultFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductResultFindUniqueOrThrowArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Find the first ProductsProductResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultFindFirstArgs} args - Arguments to find a ProductsProductResult
     * @example
     * // Get one ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsProductResultFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsProductResultFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductsProductResult'> extends True ? Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>> : Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T> | null, null>

    /**
     * Find the first ProductsProductResult that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultFindFirstOrThrowArgs} args - Arguments to find a ProductsProductResult
     * @example
     * // Get one ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductsProductResultFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductResultFindFirstOrThrowArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Find zero or more ProductsProductResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductsProductResults
     * const productsProductResults = await prisma.productsProductResult.findMany()
     * 
     * // Get first 10 ProductsProductResults
     * const productsProductResults = await prisma.productsProductResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsProductResultWithIdOnly = await prisma.productsProductResult.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsProductResultFindManyArgs>(
      args?: SelectSubset<T, ProductsProductResultFindManyArgs>
    ): PrismaPromise<Array<ProductsProductResultGetPayload<T>>>

    /**
     * Create a ProductsProductResult.
     * @param {ProductsProductResultCreateArgs} args - Arguments to create a ProductsProductResult.
     * @example
     * // Create one ProductsProductResult
     * const ProductsProductResult = await prisma.productsProductResult.create({
     *   data: {
     *     // ... data to create a ProductsProductResult
     *   }
     * })
     * 
    **/
    create<T extends ProductsProductResultCreateArgs>(
      args: SelectSubset<T, ProductsProductResultCreateArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Create many ProductsProductResults.
     *     @param {ProductsProductResultCreateManyArgs} args - Arguments to create many ProductsProductResults.
     *     @example
     *     // Create many ProductsProductResults
     *     const productsProductResult = await prisma.productsProductResult.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductsProductResultCreateManyArgs>(
      args?: SelectSubset<T, ProductsProductResultCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductsProductResult.
     * @param {ProductsProductResultDeleteArgs} args - Arguments to delete one ProductsProductResult.
     * @example
     * // Delete one ProductsProductResult
     * const ProductsProductResult = await prisma.productsProductResult.delete({
     *   where: {
     *     // ... filter to delete one ProductsProductResult
     *   }
     * })
     * 
    **/
    delete<T extends ProductsProductResultDeleteArgs>(
      args: SelectSubset<T, ProductsProductResultDeleteArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Update one ProductsProductResult.
     * @param {ProductsProductResultUpdateArgs} args - Arguments to update one ProductsProductResult.
     * @example
     * // Update one ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsProductResultUpdateArgs>(
      args: SelectSubset<T, ProductsProductResultUpdateArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Delete zero or more ProductsProductResults.
     * @param {ProductsProductResultDeleteManyArgs} args - Arguments to filter ProductsProductResults to delete.
     * @example
     * // Delete a few ProductsProductResults
     * const { count } = await prisma.productsProductResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsProductResultDeleteManyArgs>(
      args?: SelectSubset<T, ProductsProductResultDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductsProductResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductsProductResults
     * const productsProductResult = await prisma.productsProductResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsProductResultUpdateManyArgs>(
      args: SelectSubset<T, ProductsProductResultUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductsProductResult.
     * @param {ProductsProductResultUpsertArgs} args - Arguments to update or create a ProductsProductResult.
     * @example
     * // Update or create a ProductsProductResult
     * const productsProductResult = await prisma.productsProductResult.upsert({
     *   create: {
     *     // ... data to create a ProductsProductResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductsProductResult we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsProductResultUpsertArgs>(
      args: SelectSubset<T, ProductsProductResultUpsertArgs>
    ): Prisma__ProductsProductResultClient<ProductsProductResultGetPayload<T>>

    /**
     * Count the number of ProductsProductResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultCountArgs} args - Arguments to filter ProductsProductResults to count.
     * @example
     * // Count the number of ProductsProductResults
     * const count = await prisma.productsProductResult.count({
     *   where: {
     *     // ... the filter for the ProductsProductResults we want to count
     *   }
     * })
    **/
    count<T extends ProductsProductResultCountArgs>(
      args?: Subset<T, ProductsProductResultCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsProductResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductsProductResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsProductResultAggregateArgs>(args: Subset<T, ProductsProductResultAggregateArgs>): PrismaPromise<GetProductsProductResultAggregateType<T>>

    /**
     * Group by ProductsProductResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsProductResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsProductResultGroupByArgs['orderBy'] }
        : { orderBy?: ProductsProductResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsProductResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsProductResultGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductsProductResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsProductResultClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tags<T extends ProductsProductResult$tagsArgs= {}>(args?: Subset<T, ProductsProductResult$tagsArgs>): PrismaPromise<Array<TagsGetPayload<T>>| Null>;

    author<T extends AuthorProductArgs= {}>(args?: Subset<T, AuthorProductArgs>): Prisma__AuthorProductClient<AuthorProductGetPayload<T> | Null>;

    productsProduct<T extends ProductsProductResult$productsProductArgs= {}>(args?: Subset<T, ProductsProductResult$productsProductArgs>): PrismaPromise<Array<ProductsProductGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductsProductResult base type for findUnique actions
   */
  export type ProductsProductResultFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter, which ProductsProductResult to fetch.
     * 
    **/
    where: ProductsProductResultWhereUniqueInput
  }

  /**
   * ProductsProductResult findUnique
   */
  export interface ProductsProductResultFindUniqueArgs extends ProductsProductResultFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProductResult findUniqueOrThrow
   */
  export type ProductsProductResultFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter, which ProductsProductResult to fetch.
     * 
    **/
    where: ProductsProductResultWhereUniqueInput
  }


  /**
   * ProductsProductResult base type for findFirst actions
   */
  export type ProductsProductResultFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter, which ProductsProductResult to fetch.
     * 
    **/
    where?: ProductsProductResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductResults to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProductResults.
     * 
    **/
    cursor?: ProductsProductResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductResults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductResults.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProductResults.
     * 
    **/
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }

  /**
   * ProductsProductResult findFirst
   */
  export interface ProductsProductResultFindFirstArgs extends ProductsProductResultFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProductResult findFirstOrThrow
   */
  export type ProductsProductResultFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter, which ProductsProductResult to fetch.
     * 
    **/
    where?: ProductsProductResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductResults to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProductResults.
     * 
    **/
    cursor?: ProductsProductResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductResults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductResults.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProductResults.
     * 
    **/
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }


  /**
   * ProductsProductResult findMany
   */
  export type ProductsProductResultFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter, which ProductsProductResults to fetch.
     * 
    **/
    where?: ProductsProductResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductResults to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductsProductResults.
     * 
    **/
    cursor?: ProductsProductResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductResults from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductResults.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }


  /**
   * ProductsProductResult create
   */
  export type ProductsProductResultCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * The data needed to create a ProductsProductResult.
     * 
    **/
    data: XOR<ProductsProductResultCreateInput, ProductsProductResultUncheckedCreateInput>
  }


  /**
   * ProductsProductResult createMany
   */
  export type ProductsProductResultCreateManyArgs = {
    /**
     * The data used to create many ProductsProductResults.
     * 
    **/
    data: Enumerable<ProductsProductResultCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductsProductResult update
   */
  export type ProductsProductResultUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * The data needed to update a ProductsProductResult.
     * 
    **/
    data: XOR<ProductsProductResultUpdateInput, ProductsProductResultUncheckedUpdateInput>
    /**
     * Choose, which ProductsProductResult to update.
     * 
    **/
    where: ProductsProductResultWhereUniqueInput
  }


  /**
   * ProductsProductResult updateMany
   */
  export type ProductsProductResultUpdateManyArgs = {
    /**
     * The data used to update ProductsProductResults.
     * 
    **/
    data: XOR<ProductsProductResultUpdateManyMutationInput, ProductsProductResultUncheckedUpdateManyInput>
    /**
     * Filter which ProductsProductResults to update
     * 
    **/
    where?: ProductsProductResultWhereInput
  }


  /**
   * ProductsProductResult upsert
   */
  export type ProductsProductResultUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * The filter to search for the ProductsProductResult to update in case it exists.
     * 
    **/
    where: ProductsProductResultWhereUniqueInput
    /**
     * In case the ProductsProductResult found by the `where` argument doesn't exist, create a new ProductsProductResult with this data.
     * 
    **/
    create: XOR<ProductsProductResultCreateInput, ProductsProductResultUncheckedCreateInput>
    /**
     * In case the ProductsProductResult was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductsProductResultUpdateInput, ProductsProductResultUncheckedUpdateInput>
  }


  /**
   * ProductsProductResult delete
   */
  export type ProductsProductResultDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    /**
     * Filter which ProductsProductResult to delete.
     * 
    **/
    where: ProductsProductResultWhereUniqueInput
  }


  /**
   * ProductsProductResult deleteMany
   */
  export type ProductsProductResultDeleteManyArgs = {
    /**
     * Filter which ProductsProductResults to delete
     * 
    **/
    where?: ProductsProductResultWhereInput
  }


  /**
   * ProductsProductResult.tags
   */
  export type ProductsProductResult$tagsArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    where?: TagsWhereInput
    orderBy?: Enumerable<TagsOrderByWithRelationInput>
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagsScalarFieldEnum>
  }


  /**
   * ProductsProductResult.productsProduct
   */
  export type ProductsProductResult$productsProductArgs = {
    /**
     * Select specific fields to fetch from the ProductsProduct
     * 
    **/
    select?: ProductsProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductInclude | null
    where?: ProductsProductWhereInput
    orderBy?: Enumerable<ProductsProductOrderByWithRelationInput>
    cursor?: ProductsProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductsProductScalarFieldEnum>
  }


  /**
   * ProductsProductResult without action
   */
  export type ProductsProductResultArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    deliveryId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    deliveryId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    order_id: string | null
    purchaseDate: Date | null
    description: string | null
    userId: string | null
    productId: string | null
    deliveryId: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    order_id: string | null
    purchaseDate: Date | null
    description: string | null
    userId: string | null
    productId: string | null
    deliveryId: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    order_id: number
    purchaseDate: number
    description: number
    userId: number
    productId: number
    deliveryId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    deliveryId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    deliveryId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    order_id?: true
    purchaseDate?: true
    description?: true
    userId?: true
    productId?: true
    deliveryId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    order_id?: true
    purchaseDate?: true
    description?: true
    userId?: true
    productId?: true
    deliveryId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    order_id?: true
    purchaseDate?: true
    description?: true
    userId?: true
    productId?: true
    deliveryId?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    order_id: string
    purchaseDate: Date
    description: string
    userId: string
    productId: string
    deliveryId: number | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    order_id?: boolean
    purchaseDate?: boolean
    description?: boolean
    userId?: boolean
    productId?: boolean
    deliveryId?: boolean
    Delivery?: boolean | DeliveryArgs
    products?: boolean | Order$productsArgs
    customer?: boolean | UserArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }


  export type OrderInclude = {
    Delivery?: boolean | DeliveryArgs
    products?: boolean | Order$productsArgs
    customer?: boolean | UserArgs
    _count?: boolean | OrderCountOutputTypeArgs
  } 

  export type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Order :
    S extends undefined ? never :
    S extends { include: any } & (OrderArgs | OrderFindManyArgs)
    ? Order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Delivery' ? DeliveryGetPayload<S['include'][P]> | null :
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'customer' ? UserGetPayload<S['include'][P]> | null :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrderArgs | OrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Delivery' ? DeliveryGetPayload<S['select'][P]> | null :
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'customer' ? UserGetPayload<S['select'][P]> | null :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
      : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): PrismaPromise<Array<OrderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Delivery<T extends DeliveryArgs= {}>(args?: Subset<T, DeliveryArgs>): Prisma__DeliveryClient<DeliveryGetPayload<T> | Null>;

    products<T extends Order$productsArgs= {}>(args?: Subset<T, Order$productsArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    customer<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order.products
   */
  export type Order$productsArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model products_product_category
   */


  export type AggregateProducts_product_category = {
    _count: Products_product_categoryCountAggregateOutputType | null
    _avg: Products_product_categoryAvgAggregateOutputType | null
    _sum: Products_product_categorySumAggregateOutputType | null
    _min: Products_product_categoryMinAggregateOutputType | null
    _max: Products_product_categoryMaxAggregateOutputType | null
  }

  export type Products_product_categoryAvgAggregateOutputType = {
    id: number | null
    product_id: number | null
    category_id: number | null
  }

  export type Products_product_categorySumAggregateOutputType = {
    id: number | null
    product_id: number | null
    category_id: number | null
  }

  export type Products_product_categoryMinAggregateOutputType = {
    id: number | null
    product_id: number | null
    category_id: number | null
  }

  export type Products_product_categoryMaxAggregateOutputType = {
    id: number | null
    product_id: number | null
    category_id: number | null
  }

  export type Products_product_categoryCountAggregateOutputType = {
    id: number
    product_id: number
    category_id: number
    _all: number
  }


  export type Products_product_categoryAvgAggregateInputType = {
    id?: true
    product_id?: true
    category_id?: true
  }

  export type Products_product_categorySumAggregateInputType = {
    id?: true
    product_id?: true
    category_id?: true
  }

  export type Products_product_categoryMinAggregateInputType = {
    id?: true
    product_id?: true
    category_id?: true
  }

  export type Products_product_categoryMaxAggregateInputType = {
    id?: true
    product_id?: true
    category_id?: true
  }

  export type Products_product_categoryCountAggregateInputType = {
    id?: true
    product_id?: true
    category_id?: true
    _all?: true
  }

  export type Products_product_categoryAggregateArgs = {
    /**
     * Filter which products_product_category to aggregate.
     * 
    **/
    where?: products_product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: products_product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products_product_categories
    **/
    _count?: true | Products_product_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Products_product_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Products_product_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Products_product_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Products_product_categoryMaxAggregateInputType
  }

  export type GetProducts_product_categoryAggregateType<T extends Products_product_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts_product_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts_product_category[P]>
      : GetScalarType<T[P], AggregateProducts_product_category[P]>
  }




  export type Products_product_categoryGroupByArgs = {
    where?: products_product_categoryWhereInput
    orderBy?: Enumerable<products_product_categoryOrderByWithAggregationInput>
    by: Array<Products_product_categoryScalarFieldEnum>
    having?: products_product_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Products_product_categoryCountAggregateInputType | true
    _avg?: Products_product_categoryAvgAggregateInputType
    _sum?: Products_product_categorySumAggregateInputType
    _min?: Products_product_categoryMinAggregateInputType
    _max?: Products_product_categoryMaxAggregateInputType
  }


  export type Products_product_categoryGroupByOutputType = {
    id: number
    product_id: number
    category_id: number
    _count: Products_product_categoryCountAggregateOutputType | null
    _avg: Products_product_categoryAvgAggregateOutputType | null
    _sum: Products_product_categorySumAggregateOutputType | null
    _min: Products_product_categoryMinAggregateOutputType | null
    _max: Products_product_categoryMaxAggregateOutputType | null
  }

  type GetProducts_product_categoryGroupByPayload<T extends Products_product_categoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Products_product_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Products_product_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Products_product_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Products_product_categoryGroupByOutputType[P]>
        }
      >
    >


  export type products_product_categorySelect = {
    id?: boolean
    product_id?: boolean
    category_id?: boolean
  }


  export type products_product_categoryGetPayload<S extends boolean | null | undefined | products_product_categoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? products_product_category :
    S extends undefined ? never :
    S extends { include: any } & (products_product_categoryArgs | products_product_categoryFindManyArgs)
    ? products_product_category 
    : S extends { select: any } & (products_product_categoryArgs | products_product_categoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof products_product_category ? products_product_category[P] : never
  } 
      : products_product_category


  type products_product_categoryCountArgs = Merge<
    Omit<products_product_categoryFindManyArgs, 'select' | 'include'> & {
      select?: Products_product_categoryCountAggregateInputType | true
    }
  >

  export interface products_product_categoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Products_product_category that matches the filter.
     * @param {products_product_categoryFindUniqueArgs} args - Arguments to find a Products_product_category
     * @example
     * // Get one Products_product_category
     * const products_product_category = await prisma.products_product_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends products_product_categoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, products_product_categoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'products_product_category'> extends True ? Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>> : Prisma__products_product_categoryClient<products_product_categoryGetPayload<T> | null, null>

    /**
     * Find one Products_product_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {products_product_categoryFindUniqueOrThrowArgs} args - Arguments to find a Products_product_category
     * @example
     * // Get one Products_product_category
     * const products_product_category = await prisma.products_product_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends products_product_categoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, products_product_categoryFindUniqueOrThrowArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Find the first Products_product_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_categoryFindFirstArgs} args - Arguments to find a Products_product_category
     * @example
     * // Get one Products_product_category
     * const products_product_category = await prisma.products_product_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends products_product_categoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, products_product_categoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'products_product_category'> extends True ? Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>> : Prisma__products_product_categoryClient<products_product_categoryGetPayload<T> | null, null>

    /**
     * Find the first Products_product_category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_categoryFindFirstOrThrowArgs} args - Arguments to find a Products_product_category
     * @example
     * // Get one Products_product_category
     * const products_product_category = await prisma.products_product_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends products_product_categoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, products_product_categoryFindFirstOrThrowArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Find zero or more Products_product_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products_product_categories
     * const products_product_categories = await prisma.products_product_category.findMany()
     * 
     * // Get first 10 Products_product_categories
     * const products_product_categories = await prisma.products_product_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const products_product_categoryWithIdOnly = await prisma.products_product_category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends products_product_categoryFindManyArgs>(
      args?: SelectSubset<T, products_product_categoryFindManyArgs>
    ): PrismaPromise<Array<products_product_categoryGetPayload<T>>>

    /**
     * Create a Products_product_category.
     * @param {products_product_categoryCreateArgs} args - Arguments to create a Products_product_category.
     * @example
     * // Create one Products_product_category
     * const Products_product_category = await prisma.products_product_category.create({
     *   data: {
     *     // ... data to create a Products_product_category
     *   }
     * })
     * 
    **/
    create<T extends products_product_categoryCreateArgs>(
      args: SelectSubset<T, products_product_categoryCreateArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Create many Products_product_categories.
     *     @param {products_product_categoryCreateManyArgs} args - Arguments to create many Products_product_categories.
     *     @example
     *     // Create many Products_product_categories
     *     const products_product_category = await prisma.products_product_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends products_product_categoryCreateManyArgs>(
      args?: SelectSubset<T, products_product_categoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Products_product_category.
     * @param {products_product_categoryDeleteArgs} args - Arguments to delete one Products_product_category.
     * @example
     * // Delete one Products_product_category
     * const Products_product_category = await prisma.products_product_category.delete({
     *   where: {
     *     // ... filter to delete one Products_product_category
     *   }
     * })
     * 
    **/
    delete<T extends products_product_categoryDeleteArgs>(
      args: SelectSubset<T, products_product_categoryDeleteArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Update one Products_product_category.
     * @param {products_product_categoryUpdateArgs} args - Arguments to update one Products_product_category.
     * @example
     * // Update one Products_product_category
     * const products_product_category = await prisma.products_product_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends products_product_categoryUpdateArgs>(
      args: SelectSubset<T, products_product_categoryUpdateArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Delete zero or more Products_product_categories.
     * @param {products_product_categoryDeleteManyArgs} args - Arguments to filter Products_product_categories to delete.
     * @example
     * // Delete a few Products_product_categories
     * const { count } = await prisma.products_product_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends products_product_categoryDeleteManyArgs>(
      args?: SelectSubset<T, products_product_categoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products_product_categories
     * const products_product_category = await prisma.products_product_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends products_product_categoryUpdateManyArgs>(
      args: SelectSubset<T, products_product_categoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products_product_category.
     * @param {products_product_categoryUpsertArgs} args - Arguments to update or create a Products_product_category.
     * @example
     * // Update or create a Products_product_category
     * const products_product_category = await prisma.products_product_category.upsert({
     *   create: {
     *     // ... data to create a Products_product_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products_product_category we want to update
     *   }
     * })
    **/
    upsert<T extends products_product_categoryUpsertArgs>(
      args: SelectSubset<T, products_product_categoryUpsertArgs>
    ): Prisma__products_product_categoryClient<products_product_categoryGetPayload<T>>

    /**
     * Count the number of Products_product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_categoryCountArgs} args - Arguments to filter Products_product_categories to count.
     * @example
     * // Count the number of Products_product_categories
     * const count = await prisma.products_product_category.count({
     *   where: {
     *     // ... the filter for the Products_product_categories we want to count
     *   }
     * })
    **/
    count<T extends products_product_categoryCountArgs>(
      args?: Subset<T, products_product_categoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Products_product_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products_product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_product_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Products_product_categoryAggregateArgs>(args: Subset<T, Products_product_categoryAggregateArgs>): PrismaPromise<GetProducts_product_categoryAggregateType<T>>

    /**
     * Group by Products_product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_product_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Products_product_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Products_product_categoryGroupByArgs['orderBy'] }
        : { orderBy?: Products_product_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Products_product_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducts_product_categoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for products_product_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__products_product_categoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * products_product_category base type for findUnique actions
   */
  export type products_product_categoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter, which products_product_category to fetch.
     * 
    **/
    where: products_product_categoryWhereUniqueInput
  }

  /**
   * products_product_category findUnique
   */
  export interface products_product_categoryFindUniqueArgs extends products_product_categoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_product_category findUniqueOrThrow
   */
  export type products_product_categoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter, which products_product_category to fetch.
     * 
    **/
    where: products_product_categoryWhereUniqueInput
  }


  /**
   * products_product_category base type for findFirst actions
   */
  export type products_product_categoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter, which products_product_category to fetch.
     * 
    **/
    where?: products_product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_product_categories.
     * 
    **/
    cursor?: products_product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_product_categories.
     * 
    **/
    distinct?: Enumerable<Products_product_categoryScalarFieldEnum>
  }

  /**
   * products_product_category findFirst
   */
  export interface products_product_categoryFindFirstArgs extends products_product_categoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_product_category findFirstOrThrow
   */
  export type products_product_categoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter, which products_product_category to fetch.
     * 
    **/
    where?: products_product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_product_categories.
     * 
    **/
    cursor?: products_product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_product_categories.
     * 
    **/
    distinct?: Enumerable<Products_product_categoryScalarFieldEnum>
  }


  /**
   * products_product_category findMany
   */
  export type products_product_categoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter, which products_product_categories to fetch.
     * 
    **/
    where?: products_product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_categories to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products_product_categories.
     * 
    **/
    cursor?: products_product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Products_product_categoryScalarFieldEnum>
  }


  /**
   * products_product_category create
   */
  export type products_product_categoryCreateArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * The data needed to create a products_product_category.
     * 
    **/
    data: XOR<products_product_categoryCreateInput, products_product_categoryUncheckedCreateInput>
  }


  /**
   * products_product_category createMany
   */
  export type products_product_categoryCreateManyArgs = {
    /**
     * The data used to create many products_product_categories.
     * 
    **/
    data: Enumerable<products_product_categoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * products_product_category update
   */
  export type products_product_categoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * The data needed to update a products_product_category.
     * 
    **/
    data: XOR<products_product_categoryUpdateInput, products_product_categoryUncheckedUpdateInput>
    /**
     * Choose, which products_product_category to update.
     * 
    **/
    where: products_product_categoryWhereUniqueInput
  }


  /**
   * products_product_category updateMany
   */
  export type products_product_categoryUpdateManyArgs = {
    /**
     * The data used to update products_product_categories.
     * 
    **/
    data: XOR<products_product_categoryUpdateManyMutationInput, products_product_categoryUncheckedUpdateManyInput>
    /**
     * Filter which products_product_categories to update
     * 
    **/
    where?: products_product_categoryWhereInput
  }


  /**
   * products_product_category upsert
   */
  export type products_product_categoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * The filter to search for the products_product_category to update in case it exists.
     * 
    **/
    where: products_product_categoryWhereUniqueInput
    /**
     * In case the products_product_category found by the `where` argument doesn't exist, create a new products_product_category with this data.
     * 
    **/
    create: XOR<products_product_categoryCreateInput, products_product_categoryUncheckedCreateInput>
    /**
     * In case the products_product_category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<products_product_categoryUpdateInput, products_product_categoryUncheckedUpdateInput>
  }


  /**
   * products_product_category delete
   */
  export type products_product_categoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
    /**
     * Filter which products_product_category to delete.
     * 
    **/
    where: products_product_categoryWhereUniqueInput
  }


  /**
   * products_product_category deleteMany
   */
  export type products_product_categoryDeleteManyArgs = {
    /**
     * Filter which products_product_categories to delete
     * 
    **/
    where?: products_product_categoryWhereInput
  }


  /**
   * products_product_category without action
   */
  export type products_product_categoryArgs = {
    /**
     * Select specific fields to fetch from the products_product_category
     * 
    **/
    select?: products_product_categorySelect | null
  }



  /**
   * Model products_tag
   */


  export type AggregateProducts_tag = {
    _count: Products_tagCountAggregateOutputType | null
    _avg: Products_tagAvgAggregateOutputType | null
    _sum: Products_tagSumAggregateOutputType | null
    _min: Products_tagMinAggregateOutputType | null
    _max: Products_tagMaxAggregateOutputType | null
  }

  export type Products_tagAvgAggregateOutputType = {
    id: number | null
    key: number | null
  }

  export type Products_tagSumAggregateOutputType = {
    id: number | null
    key: number | null
  }

  export type Products_tagMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    slug: string | null
    key: number | null
  }

  export type Products_tagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    slug: string | null
    key: number | null
  }

  export type Products_tagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    slug: number
    key: number
    _all: number
  }


  export type Products_tagAvgAggregateInputType = {
    id?: true
    key?: true
  }

  export type Products_tagSumAggregateInputType = {
    id?: true
    key?: true
  }

  export type Products_tagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    key?: true
  }

  export type Products_tagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    key?: true
  }

  export type Products_tagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    key?: true
    _all?: true
  }

  export type Products_tagAggregateArgs = {
    /**
     * Filter which products_tag to aggregate.
     * 
    **/
    where?: products_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_tagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: products_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products_tags
    **/
    _count?: true | Products_tagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Products_tagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Products_tagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Products_tagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Products_tagMaxAggregateInputType
  }

  export type GetProducts_tagAggregateType<T extends Products_tagAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts_tag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts_tag[P]>
      : GetScalarType<T[P], AggregateProducts_tag[P]>
  }




  export type Products_tagGroupByArgs = {
    where?: products_tagWhereInput
    orderBy?: Enumerable<products_tagOrderByWithAggregationInput>
    by: Array<Products_tagScalarFieldEnum>
    having?: products_tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Products_tagCountAggregateInputType | true
    _avg?: Products_tagAvgAggregateInputType
    _sum?: Products_tagSumAggregateInputType
    _min?: Products_tagMinAggregateInputType
    _max?: Products_tagMaxAggregateInputType
  }


  export type Products_tagGroupByOutputType = {
    id: number
    name: string
    color: string
    slug: string
    key: number | null
    _count: Products_tagCountAggregateOutputType | null
    _avg: Products_tagAvgAggregateOutputType | null
    _sum: Products_tagSumAggregateOutputType | null
    _min: Products_tagMinAggregateOutputType | null
    _max: Products_tagMaxAggregateOutputType | null
  }

  type GetProducts_tagGroupByPayload<T extends Products_tagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Products_tagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Products_tagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Products_tagGroupByOutputType[P]>
            : GetScalarType<T[P], Products_tagGroupByOutputType[P]>
        }
      >
    >


  export type products_tagSelect = {
    id?: boolean
    name?: boolean
    color?: boolean
    slug?: boolean
    key?: boolean
  }


  export type products_tagGetPayload<S extends boolean | null | undefined | products_tagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? products_tag :
    S extends undefined ? never :
    S extends { include: any } & (products_tagArgs | products_tagFindManyArgs)
    ? products_tag 
    : S extends { select: any } & (products_tagArgs | products_tagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof products_tag ? products_tag[P] : never
  } 
      : products_tag


  type products_tagCountArgs = Merge<
    Omit<products_tagFindManyArgs, 'select' | 'include'> & {
      select?: Products_tagCountAggregateInputType | true
    }
  >

  export interface products_tagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Products_tag that matches the filter.
     * @param {products_tagFindUniqueArgs} args - Arguments to find a Products_tag
     * @example
     * // Get one Products_tag
     * const products_tag = await prisma.products_tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends products_tagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, products_tagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'products_tag'> extends True ? Prisma__products_tagClient<products_tagGetPayload<T>> : Prisma__products_tagClient<products_tagGetPayload<T> | null, null>

    /**
     * Find one Products_tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {products_tagFindUniqueOrThrowArgs} args - Arguments to find a Products_tag
     * @example
     * // Get one Products_tag
     * const products_tag = await prisma.products_tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends products_tagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, products_tagFindUniqueOrThrowArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Find the first Products_tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_tagFindFirstArgs} args - Arguments to find a Products_tag
     * @example
     * // Get one Products_tag
     * const products_tag = await prisma.products_tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends products_tagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, products_tagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'products_tag'> extends True ? Prisma__products_tagClient<products_tagGetPayload<T>> : Prisma__products_tagClient<products_tagGetPayload<T> | null, null>

    /**
     * Find the first Products_tag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_tagFindFirstOrThrowArgs} args - Arguments to find a Products_tag
     * @example
     * // Get one Products_tag
     * const products_tag = await prisma.products_tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends products_tagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, products_tagFindFirstOrThrowArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Find zero or more Products_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_tagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products_tags
     * const products_tags = await prisma.products_tag.findMany()
     * 
     * // Get first 10 Products_tags
     * const products_tags = await prisma.products_tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const products_tagWithIdOnly = await prisma.products_tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends products_tagFindManyArgs>(
      args?: SelectSubset<T, products_tagFindManyArgs>
    ): PrismaPromise<Array<products_tagGetPayload<T>>>

    /**
     * Create a Products_tag.
     * @param {products_tagCreateArgs} args - Arguments to create a Products_tag.
     * @example
     * // Create one Products_tag
     * const Products_tag = await prisma.products_tag.create({
     *   data: {
     *     // ... data to create a Products_tag
     *   }
     * })
     * 
    **/
    create<T extends products_tagCreateArgs>(
      args: SelectSubset<T, products_tagCreateArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Create many Products_tags.
     *     @param {products_tagCreateManyArgs} args - Arguments to create many Products_tags.
     *     @example
     *     // Create many Products_tags
     *     const products_tag = await prisma.products_tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends products_tagCreateManyArgs>(
      args?: SelectSubset<T, products_tagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Products_tag.
     * @param {products_tagDeleteArgs} args - Arguments to delete one Products_tag.
     * @example
     * // Delete one Products_tag
     * const Products_tag = await prisma.products_tag.delete({
     *   where: {
     *     // ... filter to delete one Products_tag
     *   }
     * })
     * 
    **/
    delete<T extends products_tagDeleteArgs>(
      args: SelectSubset<T, products_tagDeleteArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Update one Products_tag.
     * @param {products_tagUpdateArgs} args - Arguments to update one Products_tag.
     * @example
     * // Update one Products_tag
     * const products_tag = await prisma.products_tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends products_tagUpdateArgs>(
      args: SelectSubset<T, products_tagUpdateArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Delete zero or more Products_tags.
     * @param {products_tagDeleteManyArgs} args - Arguments to filter Products_tags to delete.
     * @example
     * // Delete a few Products_tags
     * const { count } = await prisma.products_tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends products_tagDeleteManyArgs>(
      args?: SelectSubset<T, products_tagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products_tags
     * const products_tag = await prisma.products_tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends products_tagUpdateManyArgs>(
      args: SelectSubset<T, products_tagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products_tag.
     * @param {products_tagUpsertArgs} args - Arguments to update or create a Products_tag.
     * @example
     * // Update or create a Products_tag
     * const products_tag = await prisma.products_tag.upsert({
     *   create: {
     *     // ... data to create a Products_tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products_tag we want to update
     *   }
     * })
    **/
    upsert<T extends products_tagUpsertArgs>(
      args: SelectSubset<T, products_tagUpsertArgs>
    ): Prisma__products_tagClient<products_tagGetPayload<T>>

    /**
     * Count the number of Products_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_tagCountArgs} args - Arguments to filter Products_tags to count.
     * @example
     * // Count the number of Products_tags
     * const count = await prisma.products_tag.count({
     *   where: {
     *     // ... the filter for the Products_tags we want to count
     *   }
     * })
    **/
    count<T extends products_tagCountArgs>(
      args?: Subset<T, products_tagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Products_tagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_tagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Products_tagAggregateArgs>(args: Subset<T, Products_tagAggregateArgs>): PrismaPromise<GetProducts_tagAggregateType<T>>

    /**
     * Group by Products_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Products_tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Products_tagGroupByArgs['orderBy'] }
        : { orderBy?: Products_tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Products_tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducts_tagGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for products_tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__products_tagClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * products_tag base type for findUnique actions
   */
  export type products_tagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter, which products_tag to fetch.
     * 
    **/
    where: products_tagWhereUniqueInput
  }

  /**
   * products_tag findUnique
   */
  export interface products_tagFindUniqueArgs extends products_tagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_tag findUniqueOrThrow
   */
  export type products_tagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter, which products_tag to fetch.
     * 
    **/
    where: products_tagWhereUniqueInput
  }


  /**
   * products_tag base type for findFirst actions
   */
  export type products_tagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter, which products_tag to fetch.
     * 
    **/
    where?: products_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_tagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_tags.
     * 
    **/
    cursor?: products_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_tags.
     * 
    **/
    distinct?: Enumerable<Products_tagScalarFieldEnum>
  }

  /**
   * products_tag findFirst
   */
  export interface products_tagFindFirstArgs extends products_tagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_tag findFirstOrThrow
   */
  export type products_tagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter, which products_tag to fetch.
     * 
    **/
    where?: products_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_tagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_tags.
     * 
    **/
    cursor?: products_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_tags.
     * 
    **/
    distinct?: Enumerable<Products_tagScalarFieldEnum>
  }


  /**
   * products_tag findMany
   */
  export type products_tagFindManyArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter, which products_tags to fetch.
     * 
    **/
    where?: products_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_tagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products_tags.
     * 
    **/
    cursor?: products_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Products_tagScalarFieldEnum>
  }


  /**
   * products_tag create
   */
  export type products_tagCreateArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * The data needed to create a products_tag.
     * 
    **/
    data: XOR<products_tagCreateInput, products_tagUncheckedCreateInput>
  }


  /**
   * products_tag createMany
   */
  export type products_tagCreateManyArgs = {
    /**
     * The data used to create many products_tags.
     * 
    **/
    data: Enumerable<products_tagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * products_tag update
   */
  export type products_tagUpdateArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * The data needed to update a products_tag.
     * 
    **/
    data: XOR<products_tagUpdateInput, products_tagUncheckedUpdateInput>
    /**
     * Choose, which products_tag to update.
     * 
    **/
    where: products_tagWhereUniqueInput
  }


  /**
   * products_tag updateMany
   */
  export type products_tagUpdateManyArgs = {
    /**
     * The data used to update products_tags.
     * 
    **/
    data: XOR<products_tagUpdateManyMutationInput, products_tagUncheckedUpdateManyInput>
    /**
     * Filter which products_tags to update
     * 
    **/
    where?: products_tagWhereInput
  }


  /**
   * products_tag upsert
   */
  export type products_tagUpsertArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * The filter to search for the products_tag to update in case it exists.
     * 
    **/
    where: products_tagWhereUniqueInput
    /**
     * In case the products_tag found by the `where` argument doesn't exist, create a new products_tag with this data.
     * 
    **/
    create: XOR<products_tagCreateInput, products_tagUncheckedCreateInput>
    /**
     * In case the products_tag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<products_tagUpdateInput, products_tagUncheckedUpdateInput>
  }


  /**
   * products_tag delete
   */
  export type products_tagDeleteArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
    /**
     * Filter which products_tag to delete.
     * 
    **/
    where: products_tagWhereUniqueInput
  }


  /**
   * products_tag deleteMany
   */
  export type products_tagDeleteManyArgs = {
    /**
     * Filter which products_tags to delete
     * 
    **/
    where?: products_tagWhereInput
  }


  /**
   * products_tag without action
   */
  export type products_tagArgs = {
    /**
     * Select specific fields to fetch from the products_tag
     * 
    **/
    select?: products_tagSelect | null
  }



  /**
   * Model products_product_tags
   */


  export type AggregateProducts_product_tags = {
    _count: Products_product_tagsCountAggregateOutputType | null
    _avg: Products_product_tagsAvgAggregateOutputType | null
    _sum: Products_product_tagsSumAggregateOutputType | null
    _min: Products_product_tagsMinAggregateOutputType | null
    _max: Products_product_tagsMaxAggregateOutputType | null
  }

  export type Products_product_tagsAvgAggregateOutputType = {
    id: number | null
    producy_id: number | null
    tag_id: number | null
  }

  export type Products_product_tagsSumAggregateOutputType = {
    id: number | null
    producy_id: number | null
    tag_id: number | null
  }

  export type Products_product_tagsMinAggregateOutputType = {
    id: number | null
    producy_id: number | null
    tag_id: number | null
  }

  export type Products_product_tagsMaxAggregateOutputType = {
    id: number | null
    producy_id: number | null
    tag_id: number | null
  }

  export type Products_product_tagsCountAggregateOutputType = {
    id: number
    producy_id: number
    tag_id: number
    _all: number
  }


  export type Products_product_tagsAvgAggregateInputType = {
    id?: true
    producy_id?: true
    tag_id?: true
  }

  export type Products_product_tagsSumAggregateInputType = {
    id?: true
    producy_id?: true
    tag_id?: true
  }

  export type Products_product_tagsMinAggregateInputType = {
    id?: true
    producy_id?: true
    tag_id?: true
  }

  export type Products_product_tagsMaxAggregateInputType = {
    id?: true
    producy_id?: true
    tag_id?: true
  }

  export type Products_product_tagsCountAggregateInputType = {
    id?: true
    producy_id?: true
    tag_id?: true
    _all?: true
  }

  export type Products_product_tagsAggregateArgs = {
    /**
     * Filter which products_product_tags to aggregate.
     * 
    **/
    where?: products_product_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: products_product_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products_product_tags
    **/
    _count?: true | Products_product_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Products_product_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Products_product_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Products_product_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Products_product_tagsMaxAggregateInputType
  }

  export type GetProducts_product_tagsAggregateType<T extends Products_product_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts_product_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts_product_tags[P]>
      : GetScalarType<T[P], AggregateProducts_product_tags[P]>
  }




  export type Products_product_tagsGroupByArgs = {
    where?: products_product_tagsWhereInput
    orderBy?: Enumerable<products_product_tagsOrderByWithAggregationInput>
    by: Array<Products_product_tagsScalarFieldEnum>
    having?: products_product_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Products_product_tagsCountAggregateInputType | true
    _avg?: Products_product_tagsAvgAggregateInputType
    _sum?: Products_product_tagsSumAggregateInputType
    _min?: Products_product_tagsMinAggregateInputType
    _max?: Products_product_tagsMaxAggregateInputType
  }


  export type Products_product_tagsGroupByOutputType = {
    id: number
    producy_id: number
    tag_id: number
    _count: Products_product_tagsCountAggregateOutputType | null
    _avg: Products_product_tagsAvgAggregateOutputType | null
    _sum: Products_product_tagsSumAggregateOutputType | null
    _min: Products_product_tagsMinAggregateOutputType | null
    _max: Products_product_tagsMaxAggregateOutputType | null
  }

  type GetProducts_product_tagsGroupByPayload<T extends Products_product_tagsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Products_product_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Products_product_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Products_product_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Products_product_tagsGroupByOutputType[P]>
        }
      >
    >


  export type products_product_tagsSelect = {
    id?: boolean
    producy_id?: boolean
    tag_id?: boolean
  }


  export type products_product_tagsGetPayload<S extends boolean | null | undefined | products_product_tagsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? products_product_tags :
    S extends undefined ? never :
    S extends { include: any } & (products_product_tagsArgs | products_product_tagsFindManyArgs)
    ? products_product_tags 
    : S extends { select: any } & (products_product_tagsArgs | products_product_tagsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof products_product_tags ? products_product_tags[P] : never
  } 
      : products_product_tags


  type products_product_tagsCountArgs = Merge<
    Omit<products_product_tagsFindManyArgs, 'select' | 'include'> & {
      select?: Products_product_tagsCountAggregateInputType | true
    }
  >

  export interface products_product_tagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Products_product_tags that matches the filter.
     * @param {products_product_tagsFindUniqueArgs} args - Arguments to find a Products_product_tags
     * @example
     * // Get one Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends products_product_tagsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, products_product_tagsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'products_product_tags'> extends True ? Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>> : Prisma__products_product_tagsClient<products_product_tagsGetPayload<T> | null, null>

    /**
     * Find one Products_product_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {products_product_tagsFindUniqueOrThrowArgs} args - Arguments to find a Products_product_tags
     * @example
     * // Get one Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends products_product_tagsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, products_product_tagsFindUniqueOrThrowArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Find the first Products_product_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_tagsFindFirstArgs} args - Arguments to find a Products_product_tags
     * @example
     * // Get one Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends products_product_tagsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, products_product_tagsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'products_product_tags'> extends True ? Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>> : Prisma__products_product_tagsClient<products_product_tagsGetPayload<T> | null, null>

    /**
     * Find the first Products_product_tags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_tagsFindFirstOrThrowArgs} args - Arguments to find a Products_product_tags
     * @example
     * // Get one Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends products_product_tagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, products_product_tagsFindFirstOrThrowArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Find zero or more Products_product_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findMany()
     * 
     * // Get first 10 Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const products_product_tagsWithIdOnly = await prisma.products_product_tags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends products_product_tagsFindManyArgs>(
      args?: SelectSubset<T, products_product_tagsFindManyArgs>
    ): PrismaPromise<Array<products_product_tagsGetPayload<T>>>

    /**
     * Create a Products_product_tags.
     * @param {products_product_tagsCreateArgs} args - Arguments to create a Products_product_tags.
     * @example
     * // Create one Products_product_tags
     * const Products_product_tags = await prisma.products_product_tags.create({
     *   data: {
     *     // ... data to create a Products_product_tags
     *   }
     * })
     * 
    **/
    create<T extends products_product_tagsCreateArgs>(
      args: SelectSubset<T, products_product_tagsCreateArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Create many Products_product_tags.
     *     @param {products_product_tagsCreateManyArgs} args - Arguments to create many Products_product_tags.
     *     @example
     *     // Create many Products_product_tags
     *     const products_product_tags = await prisma.products_product_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends products_product_tagsCreateManyArgs>(
      args?: SelectSubset<T, products_product_tagsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Products_product_tags.
     * @param {products_product_tagsDeleteArgs} args - Arguments to delete one Products_product_tags.
     * @example
     * // Delete one Products_product_tags
     * const Products_product_tags = await prisma.products_product_tags.delete({
     *   where: {
     *     // ... filter to delete one Products_product_tags
     *   }
     * })
     * 
    **/
    delete<T extends products_product_tagsDeleteArgs>(
      args: SelectSubset<T, products_product_tagsDeleteArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Update one Products_product_tags.
     * @param {products_product_tagsUpdateArgs} args - Arguments to update one Products_product_tags.
     * @example
     * // Update one Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends products_product_tagsUpdateArgs>(
      args: SelectSubset<T, products_product_tagsUpdateArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Delete zero or more Products_product_tags.
     * @param {products_product_tagsDeleteManyArgs} args - Arguments to filter Products_product_tags to delete.
     * @example
     * // Delete a few Products_product_tags
     * const { count } = await prisma.products_product_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends products_product_tagsDeleteManyArgs>(
      args?: SelectSubset<T, products_product_tagsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends products_product_tagsUpdateManyArgs>(
      args: SelectSubset<T, products_product_tagsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products_product_tags.
     * @param {products_product_tagsUpsertArgs} args - Arguments to update or create a Products_product_tags.
     * @example
     * // Update or create a Products_product_tags
     * const products_product_tags = await prisma.products_product_tags.upsert({
     *   create: {
     *     // ... data to create a Products_product_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products_product_tags we want to update
     *   }
     * })
    **/
    upsert<T extends products_product_tagsUpsertArgs>(
      args: SelectSubset<T, products_product_tagsUpsertArgs>
    ): Prisma__products_product_tagsClient<products_product_tagsGetPayload<T>>

    /**
     * Count the number of Products_product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_product_tagsCountArgs} args - Arguments to filter Products_product_tags to count.
     * @example
     * // Count the number of Products_product_tags
     * const count = await prisma.products_product_tags.count({
     *   where: {
     *     // ... the filter for the Products_product_tags we want to count
     *   }
     * })
    **/
    count<T extends products_product_tagsCountArgs>(
      args?: Subset<T, products_product_tagsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Products_product_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products_product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_product_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Products_product_tagsAggregateArgs>(args: Subset<T, Products_product_tagsAggregateArgs>): PrismaPromise<GetProducts_product_tagsAggregateType<T>>

    /**
     * Group by Products_product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_product_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Products_product_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Products_product_tagsGroupByArgs['orderBy'] }
        : { orderBy?: Products_product_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Products_product_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducts_product_tagsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for products_product_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__products_product_tagsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * products_product_tags base type for findUnique actions
   */
  export type products_product_tagsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter, which products_product_tags to fetch.
     * 
    **/
    where: products_product_tagsWhereUniqueInput
  }

  /**
   * products_product_tags findUnique
   */
  export interface products_product_tagsFindUniqueArgs extends products_product_tagsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_product_tags findUniqueOrThrow
   */
  export type products_product_tagsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter, which products_product_tags to fetch.
     * 
    **/
    where: products_product_tagsWhereUniqueInput
  }


  /**
   * products_product_tags base type for findFirst actions
   */
  export type products_product_tagsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter, which products_product_tags to fetch.
     * 
    **/
    where?: products_product_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_product_tags.
     * 
    **/
    cursor?: products_product_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_product_tags.
     * 
    **/
    distinct?: Enumerable<Products_product_tagsScalarFieldEnum>
  }

  /**
   * products_product_tags findFirst
   */
  export interface products_product_tagsFindFirstArgs extends products_product_tagsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_product_tags findFirstOrThrow
   */
  export type products_product_tagsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter, which products_product_tags to fetch.
     * 
    **/
    where?: products_product_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_product_tags.
     * 
    **/
    cursor?: products_product_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_product_tags.
     * 
    **/
    distinct?: Enumerable<Products_product_tagsScalarFieldEnum>
  }


  /**
   * products_product_tags findMany
   */
  export type products_product_tagsFindManyArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter, which products_product_tags to fetch.
     * 
    **/
    where?: products_product_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_product_tags to fetch.
     * 
    **/
    orderBy?: Enumerable<products_product_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products_product_tags.
     * 
    **/
    cursor?: products_product_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_product_tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_product_tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Products_product_tagsScalarFieldEnum>
  }


  /**
   * products_product_tags create
   */
  export type products_product_tagsCreateArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * The data needed to create a products_product_tags.
     * 
    **/
    data: XOR<products_product_tagsCreateInput, products_product_tagsUncheckedCreateInput>
  }


  /**
   * products_product_tags createMany
   */
  export type products_product_tagsCreateManyArgs = {
    /**
     * The data used to create many products_product_tags.
     * 
    **/
    data: Enumerable<products_product_tagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * products_product_tags update
   */
  export type products_product_tagsUpdateArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * The data needed to update a products_product_tags.
     * 
    **/
    data: XOR<products_product_tagsUpdateInput, products_product_tagsUncheckedUpdateInput>
    /**
     * Choose, which products_product_tags to update.
     * 
    **/
    where: products_product_tagsWhereUniqueInput
  }


  /**
   * products_product_tags updateMany
   */
  export type products_product_tagsUpdateManyArgs = {
    /**
     * The data used to update products_product_tags.
     * 
    **/
    data: XOR<products_product_tagsUpdateManyMutationInput, products_product_tagsUncheckedUpdateManyInput>
    /**
     * Filter which products_product_tags to update
     * 
    **/
    where?: products_product_tagsWhereInput
  }


  /**
   * products_product_tags upsert
   */
  export type products_product_tagsUpsertArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * The filter to search for the products_product_tags to update in case it exists.
     * 
    **/
    where: products_product_tagsWhereUniqueInput
    /**
     * In case the products_product_tags found by the `where` argument doesn't exist, create a new products_product_tags with this data.
     * 
    **/
    create: XOR<products_product_tagsCreateInput, products_product_tagsUncheckedCreateInput>
    /**
     * In case the products_product_tags was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<products_product_tagsUpdateInput, products_product_tagsUncheckedUpdateInput>
  }


  /**
   * products_product_tags delete
   */
  export type products_product_tagsDeleteArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
    /**
     * Filter which products_product_tags to delete.
     * 
    **/
    where: products_product_tagsWhereUniqueInput
  }


  /**
   * products_product_tags deleteMany
   */
  export type products_product_tagsDeleteManyArgs = {
    /**
     * Filter which products_product_tags to delete
     * 
    **/
    where?: products_product_tagsWhereInput
  }


  /**
   * products_product_tags without action
   */
  export type products_product_tagsArgs = {
    /**
     * Select specific fields to fetch from the products_product_tags
     * 
    **/
    select?: products_product_tagsSelect | null
  }



  /**
   * Model ProductsProductWhoLikesIt
   */


  export type AggregateProductsProductWhoLikesIt = {
    _count: ProductsProductWhoLikesItCountAggregateOutputType | null
    _avg: ProductsProductWhoLikesItAvgAggregateOutputType | null
    _sum: ProductsProductWhoLikesItSumAggregateOutputType | null
    _min: ProductsProductWhoLikesItMinAggregateOutputType | null
    _max: ProductsProductWhoLikesItMaxAggregateOutputType | null
  }

  export type ProductsProductWhoLikesItAvgAggregateOutputType = {
    id: number | null
    product_id: number | null
    user_id: number | null
  }

  export type ProductsProductWhoLikesItSumAggregateOutputType = {
    id: number | null
    product_id: number | null
    user_id: number | null
  }

  export type ProductsProductWhoLikesItMinAggregateOutputType = {
    id: number | null
    product_id: number | null
    user_id: number | null
  }

  export type ProductsProductWhoLikesItMaxAggregateOutputType = {
    id: number | null
    product_id: number | null
    user_id: number | null
  }

  export type ProductsProductWhoLikesItCountAggregateOutputType = {
    id: number
    product_id: number
    user_id: number
    _all: number
  }


  export type ProductsProductWhoLikesItAvgAggregateInputType = {
    id?: true
    product_id?: true
    user_id?: true
  }

  export type ProductsProductWhoLikesItSumAggregateInputType = {
    id?: true
    product_id?: true
    user_id?: true
  }

  export type ProductsProductWhoLikesItMinAggregateInputType = {
    id?: true
    product_id?: true
    user_id?: true
  }

  export type ProductsProductWhoLikesItMaxAggregateInputType = {
    id?: true
    product_id?: true
    user_id?: true
  }

  export type ProductsProductWhoLikesItCountAggregateInputType = {
    id?: true
    product_id?: true
    user_id?: true
    _all?: true
  }

  export type ProductsProductWhoLikesItAggregateArgs = {
    /**
     * Filter which ProductsProductWhoLikesIt to aggregate.
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductWhoLikesIts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductWhoLikesItOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductsProductWhoLikesItWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductWhoLikesIts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductWhoLikesIts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductsProductWhoLikesIts
    **/
    _count?: true | ProductsProductWhoLikesItCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsProductWhoLikesItAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsProductWhoLikesItSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsProductWhoLikesItMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsProductWhoLikesItMaxAggregateInputType
  }

  export type GetProductsProductWhoLikesItAggregateType<T extends ProductsProductWhoLikesItAggregateArgs> = {
        [P in keyof T & keyof AggregateProductsProductWhoLikesIt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductsProductWhoLikesIt[P]>
      : GetScalarType<T[P], AggregateProductsProductWhoLikesIt[P]>
  }




  export type ProductsProductWhoLikesItGroupByArgs = {
    where?: ProductsProductWhoLikesItWhereInput
    orderBy?: Enumerable<ProductsProductWhoLikesItOrderByWithAggregationInput>
    by: Array<ProductsProductWhoLikesItScalarFieldEnum>
    having?: ProductsProductWhoLikesItScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsProductWhoLikesItCountAggregateInputType | true
    _avg?: ProductsProductWhoLikesItAvgAggregateInputType
    _sum?: ProductsProductWhoLikesItSumAggregateInputType
    _min?: ProductsProductWhoLikesItMinAggregateInputType
    _max?: ProductsProductWhoLikesItMaxAggregateInputType
  }


  export type ProductsProductWhoLikesItGroupByOutputType = {
    id: number
    product_id: number
    user_id: number
    _count: ProductsProductWhoLikesItCountAggregateOutputType | null
    _avg: ProductsProductWhoLikesItAvgAggregateOutputType | null
    _sum: ProductsProductWhoLikesItSumAggregateOutputType | null
    _min: ProductsProductWhoLikesItMinAggregateOutputType | null
    _max: ProductsProductWhoLikesItMaxAggregateOutputType | null
  }

  type GetProductsProductWhoLikesItGroupByPayload<T extends ProductsProductWhoLikesItGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductsProductWhoLikesItGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsProductWhoLikesItGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsProductWhoLikesItGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsProductWhoLikesItGroupByOutputType[P]>
        }
      >
    >


  export type ProductsProductWhoLikesItSelect = {
    id?: boolean
    product_id?: boolean
    user_id?: boolean
  }


  export type ProductsProductWhoLikesItGetPayload<S extends boolean | null | undefined | ProductsProductWhoLikesItArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductsProductWhoLikesIt :
    S extends undefined ? never :
    S extends { include: any } & (ProductsProductWhoLikesItArgs | ProductsProductWhoLikesItFindManyArgs)
    ? ProductsProductWhoLikesIt 
    : S extends { select: any } & (ProductsProductWhoLikesItArgs | ProductsProductWhoLikesItFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductsProductWhoLikesIt ? ProductsProductWhoLikesIt[P] : never
  } 
      : ProductsProductWhoLikesIt


  type ProductsProductWhoLikesItCountArgs = Merge<
    Omit<ProductsProductWhoLikesItFindManyArgs, 'select' | 'include'> & {
      select?: ProductsProductWhoLikesItCountAggregateInputType | true
    }
  >

  export interface ProductsProductWhoLikesItDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProductsProductWhoLikesIt that matches the filter.
     * @param {ProductsProductWhoLikesItFindUniqueArgs} args - Arguments to find a ProductsProductWhoLikesIt
     * @example
     * // Get one ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsProductWhoLikesItFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsProductWhoLikesItFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductsProductWhoLikesIt'> extends True ? Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>> : Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T> | null, null>

    /**
     * Find one ProductsProductWhoLikesIt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductsProductWhoLikesItFindUniqueOrThrowArgs} args - Arguments to find a ProductsProductWhoLikesIt
     * @example
     * // Get one ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductsProductWhoLikesItFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductWhoLikesItFindUniqueOrThrowArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Find the first ProductsProductWhoLikesIt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItFindFirstArgs} args - Arguments to find a ProductsProductWhoLikesIt
     * @example
     * // Get one ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsProductWhoLikesItFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsProductWhoLikesItFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductsProductWhoLikesIt'> extends True ? Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>> : Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T> | null, null>

    /**
     * Find the first ProductsProductWhoLikesIt that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItFindFirstOrThrowArgs} args - Arguments to find a ProductsProductWhoLikesIt
     * @example
     * // Get one ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductsProductWhoLikesItFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductsProductWhoLikesItFindFirstOrThrowArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Find zero or more ProductsProductWhoLikesIts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductsProductWhoLikesIts
     * const productsProductWhoLikesIts = await prisma.productsProductWhoLikesIt.findMany()
     * 
     * // Get first 10 ProductsProductWhoLikesIts
     * const productsProductWhoLikesIts = await prisma.productsProductWhoLikesIt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsProductWhoLikesItWithIdOnly = await prisma.productsProductWhoLikesIt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsProductWhoLikesItFindManyArgs>(
      args?: SelectSubset<T, ProductsProductWhoLikesItFindManyArgs>
    ): PrismaPromise<Array<ProductsProductWhoLikesItGetPayload<T>>>

    /**
     * Create a ProductsProductWhoLikesIt.
     * @param {ProductsProductWhoLikesItCreateArgs} args - Arguments to create a ProductsProductWhoLikesIt.
     * @example
     * // Create one ProductsProductWhoLikesIt
     * const ProductsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.create({
     *   data: {
     *     // ... data to create a ProductsProductWhoLikesIt
     *   }
     * })
     * 
    **/
    create<T extends ProductsProductWhoLikesItCreateArgs>(
      args: SelectSubset<T, ProductsProductWhoLikesItCreateArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Create many ProductsProductWhoLikesIts.
     *     @param {ProductsProductWhoLikesItCreateManyArgs} args - Arguments to create many ProductsProductWhoLikesIts.
     *     @example
     *     // Create many ProductsProductWhoLikesIts
     *     const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductsProductWhoLikesItCreateManyArgs>(
      args?: SelectSubset<T, ProductsProductWhoLikesItCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductsProductWhoLikesIt.
     * @param {ProductsProductWhoLikesItDeleteArgs} args - Arguments to delete one ProductsProductWhoLikesIt.
     * @example
     * // Delete one ProductsProductWhoLikesIt
     * const ProductsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.delete({
     *   where: {
     *     // ... filter to delete one ProductsProductWhoLikesIt
     *   }
     * })
     * 
    **/
    delete<T extends ProductsProductWhoLikesItDeleteArgs>(
      args: SelectSubset<T, ProductsProductWhoLikesItDeleteArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Update one ProductsProductWhoLikesIt.
     * @param {ProductsProductWhoLikesItUpdateArgs} args - Arguments to update one ProductsProductWhoLikesIt.
     * @example
     * // Update one ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsProductWhoLikesItUpdateArgs>(
      args: SelectSubset<T, ProductsProductWhoLikesItUpdateArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Delete zero or more ProductsProductWhoLikesIts.
     * @param {ProductsProductWhoLikesItDeleteManyArgs} args - Arguments to filter ProductsProductWhoLikesIts to delete.
     * @example
     * // Delete a few ProductsProductWhoLikesIts
     * const { count } = await prisma.productsProductWhoLikesIt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsProductWhoLikesItDeleteManyArgs>(
      args?: SelectSubset<T, ProductsProductWhoLikesItDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductsProductWhoLikesIts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductsProductWhoLikesIts
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsProductWhoLikesItUpdateManyArgs>(
      args: SelectSubset<T, ProductsProductWhoLikesItUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductsProductWhoLikesIt.
     * @param {ProductsProductWhoLikesItUpsertArgs} args - Arguments to update or create a ProductsProductWhoLikesIt.
     * @example
     * // Update or create a ProductsProductWhoLikesIt
     * const productsProductWhoLikesIt = await prisma.productsProductWhoLikesIt.upsert({
     *   create: {
     *     // ... data to create a ProductsProductWhoLikesIt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductsProductWhoLikesIt we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsProductWhoLikesItUpsertArgs>(
      args: SelectSubset<T, ProductsProductWhoLikesItUpsertArgs>
    ): Prisma__ProductsProductWhoLikesItClient<ProductsProductWhoLikesItGetPayload<T>>

    /**
     * Count the number of ProductsProductWhoLikesIts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItCountArgs} args - Arguments to filter ProductsProductWhoLikesIts to count.
     * @example
     * // Count the number of ProductsProductWhoLikesIts
     * const count = await prisma.productsProductWhoLikesIt.count({
     *   where: {
     *     // ... the filter for the ProductsProductWhoLikesIts we want to count
     *   }
     * })
    **/
    count<T extends ProductsProductWhoLikesItCountArgs>(
      args?: Subset<T, ProductsProductWhoLikesItCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsProductWhoLikesItCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductsProductWhoLikesIt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsProductWhoLikesItAggregateArgs>(args: Subset<T, ProductsProductWhoLikesItAggregateArgs>): PrismaPromise<GetProductsProductWhoLikesItAggregateType<T>>

    /**
     * Group by ProductsProductWhoLikesIt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsProductWhoLikesItGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsProductWhoLikesItGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsProductWhoLikesItGroupByArgs['orderBy'] }
        : { orderBy?: ProductsProductWhoLikesItGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsProductWhoLikesItGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsProductWhoLikesItGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductsProductWhoLikesIt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsProductWhoLikesItClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductsProductWhoLikesIt base type for findUnique actions
   */
  export type ProductsProductWhoLikesItFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter, which ProductsProductWhoLikesIt to fetch.
     * 
    **/
    where: ProductsProductWhoLikesItWhereUniqueInput
  }

  /**
   * ProductsProductWhoLikesIt findUnique
   */
  export interface ProductsProductWhoLikesItFindUniqueArgs extends ProductsProductWhoLikesItFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProductWhoLikesIt findUniqueOrThrow
   */
  export type ProductsProductWhoLikesItFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter, which ProductsProductWhoLikesIt to fetch.
     * 
    **/
    where: ProductsProductWhoLikesItWhereUniqueInput
  }


  /**
   * ProductsProductWhoLikesIt base type for findFirst actions
   */
  export type ProductsProductWhoLikesItFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter, which ProductsProductWhoLikesIt to fetch.
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductWhoLikesIts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductWhoLikesItOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProductWhoLikesIts.
     * 
    **/
    cursor?: ProductsProductWhoLikesItWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductWhoLikesIts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductWhoLikesIts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProductWhoLikesIts.
     * 
    **/
    distinct?: Enumerable<ProductsProductWhoLikesItScalarFieldEnum>
  }

  /**
   * ProductsProductWhoLikesIt findFirst
   */
  export interface ProductsProductWhoLikesItFindFirstArgs extends ProductsProductWhoLikesItFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductsProductWhoLikesIt findFirstOrThrow
   */
  export type ProductsProductWhoLikesItFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter, which ProductsProductWhoLikesIt to fetch.
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductWhoLikesIts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductWhoLikesItOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductsProductWhoLikesIts.
     * 
    **/
    cursor?: ProductsProductWhoLikesItWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductWhoLikesIts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductWhoLikesIts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductsProductWhoLikesIts.
     * 
    **/
    distinct?: Enumerable<ProductsProductWhoLikesItScalarFieldEnum>
  }


  /**
   * ProductsProductWhoLikesIt findMany
   */
  export type ProductsProductWhoLikesItFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter, which ProductsProductWhoLikesIts to fetch.
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductsProductWhoLikesIts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductsProductWhoLikesItOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductsProductWhoLikesIts.
     * 
    **/
    cursor?: ProductsProductWhoLikesItWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductsProductWhoLikesIts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductsProductWhoLikesIts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductsProductWhoLikesItScalarFieldEnum>
  }


  /**
   * ProductsProductWhoLikesIt create
   */
  export type ProductsProductWhoLikesItCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * The data needed to create a ProductsProductWhoLikesIt.
     * 
    **/
    data: XOR<ProductsProductWhoLikesItCreateInput, ProductsProductWhoLikesItUncheckedCreateInput>
  }


  /**
   * ProductsProductWhoLikesIt createMany
   */
  export type ProductsProductWhoLikesItCreateManyArgs = {
    /**
     * The data used to create many ProductsProductWhoLikesIts.
     * 
    **/
    data: Enumerable<ProductsProductWhoLikesItCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductsProductWhoLikesIt update
   */
  export type ProductsProductWhoLikesItUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * The data needed to update a ProductsProductWhoLikesIt.
     * 
    **/
    data: XOR<ProductsProductWhoLikesItUpdateInput, ProductsProductWhoLikesItUncheckedUpdateInput>
    /**
     * Choose, which ProductsProductWhoLikesIt to update.
     * 
    **/
    where: ProductsProductWhoLikesItWhereUniqueInput
  }


  /**
   * ProductsProductWhoLikesIt updateMany
   */
  export type ProductsProductWhoLikesItUpdateManyArgs = {
    /**
     * The data used to update ProductsProductWhoLikesIts.
     * 
    **/
    data: XOR<ProductsProductWhoLikesItUpdateManyMutationInput, ProductsProductWhoLikesItUncheckedUpdateManyInput>
    /**
     * Filter which ProductsProductWhoLikesIts to update
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
  }


  /**
   * ProductsProductWhoLikesIt upsert
   */
  export type ProductsProductWhoLikesItUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * The filter to search for the ProductsProductWhoLikesIt to update in case it exists.
     * 
    **/
    where: ProductsProductWhoLikesItWhereUniqueInput
    /**
     * In case the ProductsProductWhoLikesIt found by the `where` argument doesn't exist, create a new ProductsProductWhoLikesIt with this data.
     * 
    **/
    create: XOR<ProductsProductWhoLikesItCreateInput, ProductsProductWhoLikesItUncheckedCreateInput>
    /**
     * In case the ProductsProductWhoLikesIt was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductsProductWhoLikesItUpdateInput, ProductsProductWhoLikesItUncheckedUpdateInput>
  }


  /**
   * ProductsProductWhoLikesIt delete
   */
  export type ProductsProductWhoLikesItDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
    /**
     * Filter which ProductsProductWhoLikesIt to delete.
     * 
    **/
    where: ProductsProductWhoLikesItWhereUniqueInput
  }


  /**
   * ProductsProductWhoLikesIt deleteMany
   */
  export type ProductsProductWhoLikesItDeleteManyArgs = {
    /**
     * Filter which ProductsProductWhoLikesIts to delete
     * 
    **/
    where?: ProductsProductWhoLikesItWhereInput
  }


  /**
   * ProductsProductWhoLikesIt without action
   */
  export type ProductsProductWhoLikesItArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductWhoLikesIt
     * 
    **/
    select?: ProductsProductWhoLikesItSelect | null
  }



  /**
   * Model payments_productbuyers
   */


  export type AggregatePayments_productbuyers = {
    _count: Payments_productbuyersCountAggregateOutputType | null
    _avg: Payments_productbuyersAvgAggregateOutputType | null
    _sum: Payments_productbuyersSumAggregateOutputType | null
    _min: Payments_productbuyersMinAggregateOutputType | null
    _max: Payments_productbuyersMaxAggregateOutputType | null
  }

  export type Payments_productbuyersAvgAggregateOutputType = {
    amount: number | null
  }

  export type Payments_productbuyersSumAggregateOutputType = {
    amount: number | null
  }

  export type Payments_productbuyersMinAggregateOutputType = {
    id: string | null
    amount: number | null
    backUrl: string | null
    companyName: string | null
    details: string | null
    emailReq: string | null
    errorCode: string | null
    merchantEmail: string | null
    merchantName: string | null
    message: string | null
    orderId: string | null
    paymentId: string | null
    phoneReq: string | null
    success: string | null
    tranDate: string | null
  }

  export type Payments_productbuyersMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    backUrl: string | null
    companyName: string | null
    details: string | null
    emailReq: string | null
    errorCode: string | null
    merchantEmail: string | null
    merchantName: string | null
    message: string | null
    orderId: string | null
    paymentId: string | null
    phoneReq: string | null
    success: string | null
    tranDate: string | null
  }

  export type Payments_productbuyersCountAggregateOutputType = {
    id: number
    amount: number
    backUrl: number
    companyName: number
    details: number
    emailReq: number
    errorCode: number
    merchantEmail: number
    merchantName: number
    message: number
    orderId: number
    paymentId: number
    phoneReq: number
    success: number
    tranDate: number
    _all: number
  }


  export type Payments_productbuyersAvgAggregateInputType = {
    amount?: true
  }

  export type Payments_productbuyersSumAggregateInputType = {
    amount?: true
  }

  export type Payments_productbuyersMinAggregateInputType = {
    id?: true
    amount?: true
    backUrl?: true
    companyName?: true
    details?: true
    emailReq?: true
    errorCode?: true
    merchantEmail?: true
    merchantName?: true
    message?: true
    orderId?: true
    paymentId?: true
    phoneReq?: true
    success?: true
    tranDate?: true
  }

  export type Payments_productbuyersMaxAggregateInputType = {
    id?: true
    amount?: true
    backUrl?: true
    companyName?: true
    details?: true
    emailReq?: true
    errorCode?: true
    merchantEmail?: true
    merchantName?: true
    message?: true
    orderId?: true
    paymentId?: true
    phoneReq?: true
    success?: true
    tranDate?: true
  }

  export type Payments_productbuyersCountAggregateInputType = {
    id?: true
    amount?: true
    backUrl?: true
    companyName?: true
    details?: true
    emailReq?: true
    errorCode?: true
    merchantEmail?: true
    merchantName?: true
    message?: true
    orderId?: true
    paymentId?: true
    phoneReq?: true
    success?: true
    tranDate?: true
    _all?: true
  }

  export type Payments_productbuyersAggregateArgs = {
    /**
     * Filter which payments_productbuyers to aggregate.
     * 
    **/
    where?: payments_productbuyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments_productbuyers to fetch.
     * 
    **/
    orderBy?: Enumerable<payments_productbuyersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: payments_productbuyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments_productbuyers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments_productbuyers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments_productbuyers
    **/
    _count?: true | Payments_productbuyersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payments_productbuyersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payments_productbuyersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payments_productbuyersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payments_productbuyersMaxAggregateInputType
  }

  export type GetPayments_productbuyersAggregateType<T extends Payments_productbuyersAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments_productbuyers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments_productbuyers[P]>
      : GetScalarType<T[P], AggregatePayments_productbuyers[P]>
  }




  export type Payments_productbuyersGroupByArgs = {
    where?: payments_productbuyersWhereInput
    orderBy?: Enumerable<payments_productbuyersOrderByWithAggregationInput>
    by: Array<Payments_productbuyersScalarFieldEnum>
    having?: payments_productbuyersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payments_productbuyersCountAggregateInputType | true
    _avg?: Payments_productbuyersAvgAggregateInputType
    _sum?: Payments_productbuyersSumAggregateInputType
    _min?: Payments_productbuyersMinAggregateInputType
    _max?: Payments_productbuyersMaxAggregateInputType
  }


  export type Payments_productbuyersGroupByOutputType = {
    id: string
    amount: number
    backUrl: string | null
    companyName: string | null
    details: string | null
    emailReq: string | null
    errorCode: string | null
    merchantEmail: string | null
    merchantName: string | null
    message: string | null
    orderId: string
    paymentId: string
    phoneReq: string | null
    success: string | null
    tranDate: string | null
    _count: Payments_productbuyersCountAggregateOutputType | null
    _avg: Payments_productbuyersAvgAggregateOutputType | null
    _sum: Payments_productbuyersSumAggregateOutputType | null
    _min: Payments_productbuyersMinAggregateOutputType | null
    _max: Payments_productbuyersMaxAggregateOutputType | null
  }

  type GetPayments_productbuyersGroupByPayload<T extends Payments_productbuyersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Payments_productbuyersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payments_productbuyersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payments_productbuyersGroupByOutputType[P]>
            : GetScalarType<T[P], Payments_productbuyersGroupByOutputType[P]>
        }
      >
    >


  export type payments_productbuyersSelect = {
    id?: boolean
    amount?: boolean
    backUrl?: boolean
    companyName?: boolean
    details?: boolean
    emailReq?: boolean
    errorCode?: boolean
    merchantEmail?: boolean
    merchantName?: boolean
    message?: boolean
    orderId?: boolean
    paymentId?: boolean
    phoneReq?: boolean
    success?: boolean
    tranDate?: boolean
  }


  export type payments_productbuyersGetPayload<S extends boolean | null | undefined | payments_productbuyersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? payments_productbuyers :
    S extends undefined ? never :
    S extends { include: any } & (payments_productbuyersArgs | payments_productbuyersFindManyArgs)
    ? payments_productbuyers 
    : S extends { select: any } & (payments_productbuyersArgs | payments_productbuyersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof payments_productbuyers ? payments_productbuyers[P] : never
  } 
      : payments_productbuyers


  type payments_productbuyersCountArgs = Merge<
    Omit<payments_productbuyersFindManyArgs, 'select' | 'include'> & {
      select?: Payments_productbuyersCountAggregateInputType | true
    }
  >

  export interface payments_productbuyersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Payments_productbuyers that matches the filter.
     * @param {payments_productbuyersFindUniqueArgs} args - Arguments to find a Payments_productbuyers
     * @example
     * // Get one Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends payments_productbuyersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, payments_productbuyersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payments_productbuyers'> extends True ? Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>> : Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T> | null, null>

    /**
     * Find one Payments_productbuyers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {payments_productbuyersFindUniqueOrThrowArgs} args - Arguments to find a Payments_productbuyers
     * @example
     * // Get one Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends payments_productbuyersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, payments_productbuyersFindUniqueOrThrowArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Find the first Payments_productbuyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payments_productbuyersFindFirstArgs} args - Arguments to find a Payments_productbuyers
     * @example
     * // Get one Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends payments_productbuyersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, payments_productbuyersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payments_productbuyers'> extends True ? Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>> : Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T> | null, null>

    /**
     * Find the first Payments_productbuyers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payments_productbuyersFindFirstOrThrowArgs} args - Arguments to find a Payments_productbuyers
     * @example
     * // Get one Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends payments_productbuyersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payments_productbuyersFindFirstOrThrowArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Find zero or more Payments_productbuyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payments_productbuyersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findMany()
     * 
     * // Get first 10 Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payments_productbuyersWithIdOnly = await prisma.payments_productbuyers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends payments_productbuyersFindManyArgs>(
      args?: SelectSubset<T, payments_productbuyersFindManyArgs>
    ): PrismaPromise<Array<payments_productbuyersGetPayload<T>>>

    /**
     * Create a Payments_productbuyers.
     * @param {payments_productbuyersCreateArgs} args - Arguments to create a Payments_productbuyers.
     * @example
     * // Create one Payments_productbuyers
     * const Payments_productbuyers = await prisma.payments_productbuyers.create({
     *   data: {
     *     // ... data to create a Payments_productbuyers
     *   }
     * })
     * 
    **/
    create<T extends payments_productbuyersCreateArgs>(
      args: SelectSubset<T, payments_productbuyersCreateArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Create many Payments_productbuyers.
     *     @param {payments_productbuyersCreateManyArgs} args - Arguments to create many Payments_productbuyers.
     *     @example
     *     // Create many Payments_productbuyers
     *     const payments_productbuyers = await prisma.payments_productbuyers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends payments_productbuyersCreateManyArgs>(
      args?: SelectSubset<T, payments_productbuyersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payments_productbuyers.
     * @param {payments_productbuyersDeleteArgs} args - Arguments to delete one Payments_productbuyers.
     * @example
     * // Delete one Payments_productbuyers
     * const Payments_productbuyers = await prisma.payments_productbuyers.delete({
     *   where: {
     *     // ... filter to delete one Payments_productbuyers
     *   }
     * })
     * 
    **/
    delete<T extends payments_productbuyersDeleteArgs>(
      args: SelectSubset<T, payments_productbuyersDeleteArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Update one Payments_productbuyers.
     * @param {payments_productbuyersUpdateArgs} args - Arguments to update one Payments_productbuyers.
     * @example
     * // Update one Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends payments_productbuyersUpdateArgs>(
      args: SelectSubset<T, payments_productbuyersUpdateArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Delete zero or more Payments_productbuyers.
     * @param {payments_productbuyersDeleteManyArgs} args - Arguments to filter Payments_productbuyers to delete.
     * @example
     * // Delete a few Payments_productbuyers
     * const { count } = await prisma.payments_productbuyers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends payments_productbuyersDeleteManyArgs>(
      args?: SelectSubset<T, payments_productbuyersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments_productbuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payments_productbuyersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends payments_productbuyersUpdateManyArgs>(
      args: SelectSubset<T, payments_productbuyersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments_productbuyers.
     * @param {payments_productbuyersUpsertArgs} args - Arguments to update or create a Payments_productbuyers.
     * @example
     * // Update or create a Payments_productbuyers
     * const payments_productbuyers = await prisma.payments_productbuyers.upsert({
     *   create: {
     *     // ... data to create a Payments_productbuyers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments_productbuyers we want to update
     *   }
     * })
    **/
    upsert<T extends payments_productbuyersUpsertArgs>(
      args: SelectSubset<T, payments_productbuyersUpsertArgs>
    ): Prisma__payments_productbuyersClient<payments_productbuyersGetPayload<T>>

    /**
     * Count the number of Payments_productbuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payments_productbuyersCountArgs} args - Arguments to filter Payments_productbuyers to count.
     * @example
     * // Count the number of Payments_productbuyers
     * const count = await prisma.payments_productbuyers.count({
     *   where: {
     *     // ... the filter for the Payments_productbuyers we want to count
     *   }
     * })
    **/
    count<T extends payments_productbuyersCountArgs>(
      args?: Subset<T, payments_productbuyersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payments_productbuyersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments_productbuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payments_productbuyersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payments_productbuyersAggregateArgs>(args: Subset<T, Payments_productbuyersAggregateArgs>): PrismaPromise<GetPayments_productbuyersAggregateType<T>>

    /**
     * Group by Payments_productbuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payments_productbuyersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Payments_productbuyersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Payments_productbuyersGroupByArgs['orderBy'] }
        : { orderBy?: Payments_productbuyersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Payments_productbuyersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayments_productbuyersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payments_productbuyers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__payments_productbuyersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payments_productbuyers base type for findUnique actions
   */
  export type payments_productbuyersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter, which payments_productbuyers to fetch.
     * 
    **/
    where: payments_productbuyersWhereUniqueInput
  }

  /**
   * payments_productbuyers findUnique
   */
  export interface payments_productbuyersFindUniqueArgs extends payments_productbuyersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payments_productbuyers findUniqueOrThrow
   */
  export type payments_productbuyersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter, which payments_productbuyers to fetch.
     * 
    **/
    where: payments_productbuyersWhereUniqueInput
  }


  /**
   * payments_productbuyers base type for findFirst actions
   */
  export type payments_productbuyersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter, which payments_productbuyers to fetch.
     * 
    **/
    where?: payments_productbuyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments_productbuyers to fetch.
     * 
    **/
    orderBy?: Enumerable<payments_productbuyersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments_productbuyers.
     * 
    **/
    cursor?: payments_productbuyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments_productbuyers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments_productbuyers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments_productbuyers.
     * 
    **/
    distinct?: Enumerable<Payments_productbuyersScalarFieldEnum>
  }

  /**
   * payments_productbuyers findFirst
   */
  export interface payments_productbuyersFindFirstArgs extends payments_productbuyersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payments_productbuyers findFirstOrThrow
   */
  export type payments_productbuyersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter, which payments_productbuyers to fetch.
     * 
    **/
    where?: payments_productbuyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments_productbuyers to fetch.
     * 
    **/
    orderBy?: Enumerable<payments_productbuyersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments_productbuyers.
     * 
    **/
    cursor?: payments_productbuyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments_productbuyers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments_productbuyers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments_productbuyers.
     * 
    **/
    distinct?: Enumerable<Payments_productbuyersScalarFieldEnum>
  }


  /**
   * payments_productbuyers findMany
   */
  export type payments_productbuyersFindManyArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter, which payments_productbuyers to fetch.
     * 
    **/
    where?: payments_productbuyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments_productbuyers to fetch.
     * 
    **/
    orderBy?: Enumerable<payments_productbuyersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments_productbuyers.
     * 
    **/
    cursor?: payments_productbuyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments_productbuyers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments_productbuyers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Payments_productbuyersScalarFieldEnum>
  }


  /**
   * payments_productbuyers create
   */
  export type payments_productbuyersCreateArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * The data needed to create a payments_productbuyers.
     * 
    **/
    data: XOR<payments_productbuyersCreateInput, payments_productbuyersUncheckedCreateInput>
  }


  /**
   * payments_productbuyers createMany
   */
  export type payments_productbuyersCreateManyArgs = {
    /**
     * The data used to create many payments_productbuyers.
     * 
    **/
    data: Enumerable<payments_productbuyersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payments_productbuyers update
   */
  export type payments_productbuyersUpdateArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * The data needed to update a payments_productbuyers.
     * 
    **/
    data: XOR<payments_productbuyersUpdateInput, payments_productbuyersUncheckedUpdateInput>
    /**
     * Choose, which payments_productbuyers to update.
     * 
    **/
    where: payments_productbuyersWhereUniqueInput
  }


  /**
   * payments_productbuyers updateMany
   */
  export type payments_productbuyersUpdateManyArgs = {
    /**
     * The data used to update payments_productbuyers.
     * 
    **/
    data: XOR<payments_productbuyersUpdateManyMutationInput, payments_productbuyersUncheckedUpdateManyInput>
    /**
     * Filter which payments_productbuyers to update
     * 
    **/
    where?: payments_productbuyersWhereInput
  }


  /**
   * payments_productbuyers upsert
   */
  export type payments_productbuyersUpsertArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * The filter to search for the payments_productbuyers to update in case it exists.
     * 
    **/
    where: payments_productbuyersWhereUniqueInput
    /**
     * In case the payments_productbuyers found by the `where` argument doesn't exist, create a new payments_productbuyers with this data.
     * 
    **/
    create: XOR<payments_productbuyersCreateInput, payments_productbuyersUncheckedCreateInput>
    /**
     * In case the payments_productbuyers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<payments_productbuyersUpdateInput, payments_productbuyersUncheckedUpdateInput>
  }


  /**
   * payments_productbuyers delete
   */
  export type payments_productbuyersDeleteArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
    /**
     * Filter which payments_productbuyers to delete.
     * 
    **/
    where: payments_productbuyersWhereUniqueInput
  }


  /**
   * payments_productbuyers deleteMany
   */
  export type payments_productbuyersDeleteManyArgs = {
    /**
     * Filter which payments_productbuyers to delete
     * 
    **/
    where?: payments_productbuyersWhereInput
  }


  /**
   * payments_productbuyers without action
   */
  export type payments_productbuyersArgs = {
    /**
     * Select specific fields to fetch from the payments_productbuyers
     * 
    **/
    select?: payments_productbuyersSelect | null
  }



  /**
   * Model AuthorProduct
   */


  export type AggregateAuthorProduct = {
    _count: AuthorProductCountAggregateOutputType | null
    _min: AuthorProductMinAggregateOutputType | null
    _max: AuthorProductMaxAggregateOutputType | null
  }

  export type AuthorProductMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    first_name: string | null
    last_name: string | null
    is_subscribed: boolean | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    image_file_user: string | null
    auth_is_telegram: boolean | null
    auth_is_yandex: boolean | null
    auth_is_google: boolean | null
    is_admin_constructor: boolean | null
  }

  export type AuthorProductMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    first_name: string | null
    last_name: string | null
    is_subscribed: boolean | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    image_file_user: string | null
    auth_is_telegram: boolean | null
    auth_is_yandex: boolean | null
    auth_is_google: boolean | null
    is_admin_constructor: boolean | null
  }

  export type AuthorProductCountAggregateOutputType = {
    id: number
    email: number
    username: number
    first_name: number
    last_name: number
    is_subscribed: number
    phone_user: number
    trademark: number
    locale_user: number
    image_url_user: number
    image_file_user: number
    auth_is_telegram: number
    auth_is_yandex: number
    auth_is_google: number
    is_admin_constructor: number
    _all: number
  }


  export type AuthorProductMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    first_name?: true
    last_name?: true
    is_subscribed?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    image_file_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    is_admin_constructor?: true
  }

  export type AuthorProductMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    first_name?: true
    last_name?: true
    is_subscribed?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    image_file_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    is_admin_constructor?: true
  }

  export type AuthorProductCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    first_name?: true
    last_name?: true
    is_subscribed?: true
    phone_user?: true
    trademark?: true
    locale_user?: true
    image_url_user?: true
    image_file_user?: true
    auth_is_telegram?: true
    auth_is_yandex?: true
    auth_is_google?: true
    is_admin_constructor?: true
    _all?: true
  }

  export type AuthorProductAggregateArgs = {
    /**
     * Filter which AuthorProduct to aggregate.
     * 
    **/
    where?: AuthorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<AuthorProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AuthorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorProducts
    **/
    _count?: true | AuthorProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorProductMaxAggregateInputType
  }

  export type GetAuthorProductAggregateType<T extends AuthorProductAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorProduct[P]>
      : GetScalarType<T[P], AggregateAuthorProduct[P]>
  }




  export type AuthorProductGroupByArgs = {
    where?: AuthorProductWhereInput
    orderBy?: Enumerable<AuthorProductOrderByWithAggregationInput>
    by: Array<AuthorProductScalarFieldEnum>
    having?: AuthorProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorProductCountAggregateInputType | true
    _min?: AuthorProductMinAggregateInputType
    _max?: AuthorProductMaxAggregateInputType
  }


  export type AuthorProductGroupByOutputType = {
    id: string
    email: string
    username: string | null
    first_name: string | null
    last_name: string | null
    is_subscribed: boolean | null
    phone_user: string | null
    trademark: string | null
    locale_user: string | null
    image_url_user: string | null
    image_file_user: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
    _count: AuthorProductCountAggregateOutputType | null
    _min: AuthorProductMinAggregateOutputType | null
    _max: AuthorProductMaxAggregateOutputType | null
  }

  type GetAuthorProductGroupByPayload<T extends AuthorProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AuthorProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorProductGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorProductGroupByOutputType[P]>
        }
      >
    >


  export type AuthorProductSelect = {
    id?: boolean
    email?: boolean
    username?: boolean
    first_name?: boolean
    last_name?: boolean
    is_subscribed?: boolean
    phone_user?: boolean
    trademark?: boolean
    locale_user?: boolean
    image_url_user?: boolean
    image_file_user?: boolean
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    is_admin_constructor?: boolean
    ProductsProductResult?: boolean | AuthorProduct$ProductsProductResultArgs
    _count?: boolean | AuthorProductCountOutputTypeArgs
  }


  export type AuthorProductInclude = {
    ProductsProductResult?: boolean | AuthorProduct$ProductsProductResultArgs
    _count?: boolean | AuthorProductCountOutputTypeArgs
  } 

  export type AuthorProductGetPayload<S extends boolean | null | undefined | AuthorProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorProduct :
    S extends undefined ? never :
    S extends { include: any } & (AuthorProductArgs | AuthorProductFindManyArgs)
    ? AuthorProduct  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ProductsProductResult' ? Array < ProductsProductResultGetPayload<S['include'][P]>>  :
        P extends '_count' ? AuthorProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthorProductArgs | AuthorProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ProductsProductResult' ? Array < ProductsProductResultGetPayload<S['select'][P]>>  :
        P extends '_count' ? AuthorProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof AuthorProduct ? AuthorProduct[P] : never
  } 
      : AuthorProduct


  type AuthorProductCountArgs = Merge<
    Omit<AuthorProductFindManyArgs, 'select' | 'include'> & {
      select?: AuthorProductCountAggregateInputType | true
    }
  >

  export interface AuthorProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AuthorProduct that matches the filter.
     * @param {AuthorProductFindUniqueArgs} args - Arguments to find a AuthorProduct
     * @example
     * // Get one AuthorProduct
     * const authorProduct = await prisma.authorProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuthorProduct'> extends True ? Prisma__AuthorProductClient<AuthorProductGetPayload<T>> : Prisma__AuthorProductClient<AuthorProductGetPayload<T> | null, null>

    /**
     * Find one AuthorProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthorProductFindUniqueOrThrowArgs} args - Arguments to find a AuthorProduct
     * @example
     * // Get one AuthorProduct
     * const authorProduct = await prisma.authorProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthorProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthorProductFindUniqueOrThrowArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Find the first AuthorProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductFindFirstArgs} args - Arguments to find a AuthorProduct
     * @example
     * // Get one AuthorProduct
     * const authorProduct = await prisma.authorProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuthorProduct'> extends True ? Prisma__AuthorProductClient<AuthorProductGetPayload<T>> : Prisma__AuthorProductClient<AuthorProductGetPayload<T> | null, null>

    /**
     * Find the first AuthorProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductFindFirstOrThrowArgs} args - Arguments to find a AuthorProduct
     * @example
     * // Get one AuthorProduct
     * const authorProduct = await prisma.authorProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthorProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthorProductFindFirstOrThrowArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Find zero or more AuthorProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorProducts
     * const authorProducts = await prisma.authorProduct.findMany()
     * 
     * // Get first 10 AuthorProducts
     * const authorProducts = await prisma.authorProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorProductWithIdOnly = await prisma.authorProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthorProductFindManyArgs>(
      args?: SelectSubset<T, AuthorProductFindManyArgs>
    ): PrismaPromise<Array<AuthorProductGetPayload<T>>>

    /**
     * Create a AuthorProduct.
     * @param {AuthorProductCreateArgs} args - Arguments to create a AuthorProduct.
     * @example
     * // Create one AuthorProduct
     * const AuthorProduct = await prisma.authorProduct.create({
     *   data: {
     *     // ... data to create a AuthorProduct
     *   }
     * })
     * 
    **/
    create<T extends AuthorProductCreateArgs>(
      args: SelectSubset<T, AuthorProductCreateArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Create many AuthorProducts.
     *     @param {AuthorProductCreateManyArgs} args - Arguments to create many AuthorProducts.
     *     @example
     *     // Create many AuthorProducts
     *     const authorProduct = await prisma.authorProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthorProductCreateManyArgs>(
      args?: SelectSubset<T, AuthorProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AuthorProduct.
     * @param {AuthorProductDeleteArgs} args - Arguments to delete one AuthorProduct.
     * @example
     * // Delete one AuthorProduct
     * const AuthorProduct = await prisma.authorProduct.delete({
     *   where: {
     *     // ... filter to delete one AuthorProduct
     *   }
     * })
     * 
    **/
    delete<T extends AuthorProductDeleteArgs>(
      args: SelectSubset<T, AuthorProductDeleteArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Update one AuthorProduct.
     * @param {AuthorProductUpdateArgs} args - Arguments to update one AuthorProduct.
     * @example
     * // Update one AuthorProduct
     * const authorProduct = await prisma.authorProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorProductUpdateArgs>(
      args: SelectSubset<T, AuthorProductUpdateArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Delete zero or more AuthorProducts.
     * @param {AuthorProductDeleteManyArgs} args - Arguments to filter AuthorProducts to delete.
     * @example
     * // Delete a few AuthorProducts
     * const { count } = await prisma.authorProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorProductDeleteManyArgs>(
      args?: SelectSubset<T, AuthorProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorProducts
     * const authorProduct = await prisma.authorProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorProductUpdateManyArgs>(
      args: SelectSubset<T, AuthorProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorProduct.
     * @param {AuthorProductUpsertArgs} args - Arguments to update or create a AuthorProduct.
     * @example
     * // Update or create a AuthorProduct
     * const authorProduct = await prisma.authorProduct.upsert({
     *   create: {
     *     // ... data to create a AuthorProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorProduct we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorProductUpsertArgs>(
      args: SelectSubset<T, AuthorProductUpsertArgs>
    ): Prisma__AuthorProductClient<AuthorProductGetPayload<T>>

    /**
     * Count the number of AuthorProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductCountArgs} args - Arguments to filter AuthorProducts to count.
     * @example
     * // Count the number of AuthorProducts
     * const count = await prisma.authorProduct.count({
     *   where: {
     *     // ... the filter for the AuthorProducts we want to count
     *   }
     * })
    **/
    count<T extends AuthorProductCountArgs>(
      args?: Subset<T, AuthorProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorProductAggregateArgs>(args: Subset<T, AuthorProductAggregateArgs>): PrismaPromise<GetAuthorProductAggregateType<T>>

    /**
     * Group by AuthorProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorProductGroupByArgs['orderBy'] }
        : { orderBy?: AuthorProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductsProductResult<T extends AuthorProduct$ProductsProductResultArgs= {}>(args?: Subset<T, AuthorProduct$ProductsProductResultArgs>): PrismaPromise<Array<ProductsProductResultGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuthorProduct base type for findUnique actions
   */
  export type AuthorProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter, which AuthorProduct to fetch.
     * 
    **/
    where: AuthorProductWhereUniqueInput
  }

  /**
   * AuthorProduct findUnique
   */
  export interface AuthorProductFindUniqueArgs extends AuthorProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorProduct findUniqueOrThrow
   */
  export type AuthorProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter, which AuthorProduct to fetch.
     * 
    **/
    where: AuthorProductWhereUniqueInput
  }


  /**
   * AuthorProduct base type for findFirst actions
   */
  export type AuthorProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter, which AuthorProduct to fetch.
     * 
    **/
    where?: AuthorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<AuthorProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorProducts.
     * 
    **/
    cursor?: AuthorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorProducts.
     * 
    **/
    distinct?: Enumerable<AuthorProductScalarFieldEnum>
  }

  /**
   * AuthorProduct findFirst
   */
  export interface AuthorProductFindFirstArgs extends AuthorProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorProduct findFirstOrThrow
   */
  export type AuthorProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter, which AuthorProduct to fetch.
     * 
    **/
    where?: AuthorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<AuthorProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorProducts.
     * 
    **/
    cursor?: AuthorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorProducts.
     * 
    **/
    distinct?: Enumerable<AuthorProductScalarFieldEnum>
  }


  /**
   * AuthorProduct findMany
   */
  export type AuthorProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter, which AuthorProducts to fetch.
     * 
    **/
    where?: AuthorProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<AuthorProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorProducts.
     * 
    **/
    cursor?: AuthorProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AuthorProductScalarFieldEnum>
  }


  /**
   * AuthorProduct create
   */
  export type AuthorProductCreateArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * The data needed to create a AuthorProduct.
     * 
    **/
    data: XOR<AuthorProductCreateInput, AuthorProductUncheckedCreateInput>
  }


  /**
   * AuthorProduct createMany
   */
  export type AuthorProductCreateManyArgs = {
    /**
     * The data used to create many AuthorProducts.
     * 
    **/
    data: Enumerable<AuthorProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuthorProduct update
   */
  export type AuthorProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * The data needed to update a AuthorProduct.
     * 
    **/
    data: XOR<AuthorProductUpdateInput, AuthorProductUncheckedUpdateInput>
    /**
     * Choose, which AuthorProduct to update.
     * 
    **/
    where: AuthorProductWhereUniqueInput
  }


  /**
   * AuthorProduct updateMany
   */
  export type AuthorProductUpdateManyArgs = {
    /**
     * The data used to update AuthorProducts.
     * 
    **/
    data: XOR<AuthorProductUpdateManyMutationInput, AuthorProductUncheckedUpdateManyInput>
    /**
     * Filter which AuthorProducts to update
     * 
    **/
    where?: AuthorProductWhereInput
  }


  /**
   * AuthorProduct upsert
   */
  export type AuthorProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * The filter to search for the AuthorProduct to update in case it exists.
     * 
    **/
    where: AuthorProductWhereUniqueInput
    /**
     * In case the AuthorProduct found by the `where` argument doesn't exist, create a new AuthorProduct with this data.
     * 
    **/
    create: XOR<AuthorProductCreateInput, AuthorProductUncheckedCreateInput>
    /**
     * In case the AuthorProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AuthorProductUpdateInput, AuthorProductUncheckedUpdateInput>
  }


  /**
   * AuthorProduct delete
   */
  export type AuthorProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
    /**
     * Filter which AuthorProduct to delete.
     * 
    **/
    where: AuthorProductWhereUniqueInput
  }


  /**
   * AuthorProduct deleteMany
   */
  export type AuthorProductDeleteManyArgs = {
    /**
     * Filter which AuthorProducts to delete
     * 
    **/
    where?: AuthorProductWhereInput
  }


  /**
   * AuthorProduct.ProductsProductResult
   */
  export type AuthorProduct$ProductsProductResultArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    where?: ProductsProductResultWhereInput
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    cursor?: ProductsProductResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }


  /**
   * AuthorProduct without action
   */
  export type AuthorProductArgs = {
    /**
     * Select specific fields to fetch from the AuthorProduct
     * 
    **/
    select?: AuthorProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AuthorProductInclude | null
  }



  /**
   * Model Tags
   */


  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    id: number | null
    productsProductResultId: number | null
  }

  export type TagsSumAggregateOutputType = {
    id: number | null
    productsProductResultId: number | null
  }

  export type TagsMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    slug: string | null
    productsProductResultId: number | null
  }

  export type TagsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    slug: string | null
    productsProductResultId: number | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    color: number
    slug: number
    productsProductResultId: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    id?: true
    productsProductResultId?: true
  }

  export type TagsSumAggregateInputType = {
    id?: true
    productsProductResultId?: true
  }

  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    productsProductResultId?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    productsProductResultId?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    slug?: true
    productsProductResultId?: true
    _all?: true
  }

  export type TagsAggregateArgs = {
    /**
     * Filter which Tags to aggregate.
     * 
    **/
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs = {
    where?: TagsWhereInput
    orderBy?: Enumerable<TagsOrderByWithAggregationInput>
    by: Array<TagsScalarFieldEnum>
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }


  export type TagsGroupByOutputType = {
    id: number
    name: string | null
    color: string | null
    slug: string | null
    productsProductResultId: number | null
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect = {
    id?: boolean
    name?: boolean
    color?: boolean
    slug?: boolean
    ProductsProductResult?: boolean | Tags$ProductsProductResultArgs
    productsProductResultId?: boolean
    _count?: boolean | TagsCountOutputTypeArgs
  }


  export type TagsInclude = {
    ProductsProductResult?: boolean | Tags$ProductsProductResultArgs
    _count?: boolean | TagsCountOutputTypeArgs
  } 

  export type TagsGetPayload<S extends boolean | null | undefined | TagsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tags :
    S extends undefined ? never :
    S extends { include: any } & (TagsArgs | TagsFindManyArgs)
    ? Tags  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ProductsProductResult' ? Array < ProductsProductResultGetPayload<S['include'][P]>>  :
        P extends '_count' ? TagsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TagsArgs | TagsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ProductsProductResult' ? Array < ProductsProductResultGetPayload<S['select'][P]>>  :
        P extends '_count' ? TagsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tags ? Tags[P] : never
  } 
      : Tags


  type TagsCountArgs = Merge<
    Omit<TagsFindManyArgs, 'select' | 'include'> & {
      select?: TagsCountAggregateInputType | true
    }
  >

  export interface TagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tags'> extends True ? Prisma__TagsClient<TagsGetPayload<T>> : Prisma__TagsClient<TagsGetPayload<T> | null, null>

    /**
     * Find one Tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagsFindUniqueOrThrowArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tags'> extends True ? Prisma__TagsClient<TagsGetPayload<T>> : Prisma__TagsClient<TagsGetPayload<T> | null, null>

    /**
     * Find the first Tags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagsFindFirstOrThrowArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagsFindManyArgs>(
      args?: SelectSubset<T, TagsFindManyArgs>
    ): PrismaPromise<Array<TagsGetPayload<T>>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
    **/
    create<T extends TagsCreateArgs>(
      args: SelectSubset<T, TagsCreateArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Create many Tags.
     *     @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tags = await prisma.tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagsCreateManyArgs>(
      args?: SelectSubset<T, TagsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
    **/
    delete<T extends TagsDeleteArgs>(
      args: SelectSubset<T, TagsDeleteArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagsUpdateArgs>(
      args: SelectSubset<T, TagsUpdateArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagsDeleteManyArgs>(
      args?: SelectSubset<T, TagsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagsUpdateManyArgs>(
      args: SelectSubset<T, TagsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
    **/
    upsert<T extends TagsUpsertArgs>(
      args: SelectSubset<T, TagsUpsertArgs>
    ): Prisma__TagsClient<TagsGetPayload<T>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductsProductResult<T extends Tags$ProductsProductResultArgs= {}>(args?: Subset<T, Tags$ProductsProductResultArgs>): PrismaPromise<Array<ProductsProductResultGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tags base type for findUnique actions
   */
  export type TagsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUnique
   */
  export interface TagsFindUniqueArgs extends TagsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where: TagsWhereUniqueInput
  }


  /**
   * Tags base type for findFirst actions
   */
  export type TagsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagsScalarFieldEnum>
  }

  /**
   * Tags findFirst
   */
  export interface TagsFindFirstArgs extends TagsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagsScalarFieldEnum>
  }


  /**
   * Tags findMany
   */
  export type TagsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     * 
    **/
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TagsScalarFieldEnum>
  }


  /**
   * Tags create
   */
  export type TagsCreateArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * The data needed to create a Tags.
     * 
    **/
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }


  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs = {
    /**
     * The data used to create many Tags.
     * 
    **/
    data: Enumerable<TagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tags update
   */
  export type TagsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * The data needed to update a Tags.
     * 
    **/
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     * 
    **/
    where: TagsWhereUniqueInput
  }


  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs = {
    /**
     * The data used to update Tags.
     * 
    **/
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     * 
    **/
    where?: TagsWhereInput
  }


  /**
   * Tags upsert
   */
  export type TagsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * The filter to search for the Tags to update in case it exists.
     * 
    **/
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     * 
    **/
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }


  /**
   * Tags delete
   */
  export type TagsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
    /**
     * Filter which Tags to delete.
     * 
    **/
    where: TagsWhereUniqueInput
  }


  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs = {
    /**
     * Filter which Tags to delete
     * 
    **/
    where?: TagsWhereInput
  }


  /**
   * Tags.ProductsProductResult
   */
  export type Tags$ProductsProductResultArgs = {
    /**
     * Select specific fields to fetch from the ProductsProductResult
     * 
    **/
    select?: ProductsProductResultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductsProductResultInclude | null
    where?: ProductsProductResultWhereInput
    orderBy?: Enumerable<ProductsProductResultOrderByWithRelationInput>
    cursor?: ProductsProductResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductsProductResultScalarFieldEnum>
  }


  /**
   * Tags without action
   */
  export type TagsArgs = {
    /**
     * Select specific fields to fetch from the Tags
     * 
    **/
    select?: TagsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagsInclude | null
  }



  /**
   * Model UserFavoritesProduct
   */


  export type AggregateUserFavoritesProduct = {
    _count: UserFavoritesProductCountAggregateOutputType | null
    _avg: UserFavoritesProductAvgAggregateOutputType | null
    _sum: UserFavoritesProductSumAggregateOutputType | null
    _min: UserFavoritesProductMinAggregateOutputType | null
    _max: UserFavoritesProductMaxAggregateOutputType | null
  }

  export type UserFavoritesProductAvgAggregateOutputType = {
    id: number | null
  }

  export type UserFavoritesProductSumAggregateOutputType = {
    id: number | null
  }

  export type UserFavoritesProductMinAggregateOutputType = {
    id: number | null
    is_favorite: boolean | null
    userId: string | null
    productId: string | null
  }

  export type UserFavoritesProductMaxAggregateOutputType = {
    id: number | null
    is_favorite: boolean | null
    userId: string | null
    productId: string | null
  }

  export type UserFavoritesProductCountAggregateOutputType = {
    id: number
    is_favorite: number
    userId: number
    productId: number
    _all: number
  }


  export type UserFavoritesProductAvgAggregateInputType = {
    id?: true
  }

  export type UserFavoritesProductSumAggregateInputType = {
    id?: true
  }

  export type UserFavoritesProductMinAggregateInputType = {
    id?: true
    is_favorite?: true
    userId?: true
    productId?: true
  }

  export type UserFavoritesProductMaxAggregateInputType = {
    id?: true
    is_favorite?: true
    userId?: true
    productId?: true
  }

  export type UserFavoritesProductCountAggregateInputType = {
    id?: true
    is_favorite?: true
    userId?: true
    productId?: true
    _all?: true
  }

  export type UserFavoritesProductAggregateArgs = {
    /**
     * Filter which UserFavoritesProduct to aggregate.
     * 
    **/
    where?: UserFavoritesProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoritesProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserFavoritesProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserFavoritesProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoritesProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoritesProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavoritesProducts
    **/
    _count?: true | UserFavoritesProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFavoritesProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFavoritesProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoritesProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoritesProductMaxAggregateInputType
  }

  export type GetUserFavoritesProductAggregateType<T extends UserFavoritesProductAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavoritesProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavoritesProduct[P]>
      : GetScalarType<T[P], AggregateUserFavoritesProduct[P]>
  }




  export type UserFavoritesProductGroupByArgs = {
    where?: UserFavoritesProductWhereInput
    orderBy?: Enumerable<UserFavoritesProductOrderByWithAggregationInput>
    by: Array<UserFavoritesProductScalarFieldEnum>
    having?: UserFavoritesProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoritesProductCountAggregateInputType | true
    _avg?: UserFavoritesProductAvgAggregateInputType
    _sum?: UserFavoritesProductSumAggregateInputType
    _min?: UserFavoritesProductMinAggregateInputType
    _max?: UserFavoritesProductMaxAggregateInputType
  }


  export type UserFavoritesProductGroupByOutputType = {
    id: number
    is_favorite: boolean
    userId: string
    productId: string
    _count: UserFavoritesProductCountAggregateOutputType | null
    _avg: UserFavoritesProductAvgAggregateOutputType | null
    _sum: UserFavoritesProductSumAggregateOutputType | null
    _min: UserFavoritesProductMinAggregateOutputType | null
    _max: UserFavoritesProductMaxAggregateOutputType | null
  }

  type GetUserFavoritesProductGroupByPayload<T extends UserFavoritesProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserFavoritesProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoritesProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoritesProductGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoritesProductGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoritesProductSelect = {
    id?: boolean
    is_favorite?: boolean
    userId?: boolean
    productId?: boolean
  }


  export type UserFavoritesProductGetPayload<S extends boolean | null | undefined | UserFavoritesProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserFavoritesProduct :
    S extends undefined ? never :
    S extends { include: any } & (UserFavoritesProductArgs | UserFavoritesProductFindManyArgs)
    ? UserFavoritesProduct 
    : S extends { select: any } & (UserFavoritesProductArgs | UserFavoritesProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserFavoritesProduct ? UserFavoritesProduct[P] : never
  } 
      : UserFavoritesProduct


  type UserFavoritesProductCountArgs = Merge<
    Omit<UserFavoritesProductFindManyArgs, 'select' | 'include'> & {
      select?: UserFavoritesProductCountAggregateInputType | true
    }
  >

  export interface UserFavoritesProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserFavoritesProduct that matches the filter.
     * @param {UserFavoritesProductFindUniqueArgs} args - Arguments to find a UserFavoritesProduct
     * @example
     * // Get one UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFavoritesProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFavoritesProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserFavoritesProduct'> extends True ? Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>> : Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T> | null, null>

    /**
     * Find one UserFavoritesProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFavoritesProductFindUniqueOrThrowArgs} args - Arguments to find a UserFavoritesProduct
     * @example
     * // Get one UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFavoritesProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFavoritesProductFindUniqueOrThrowArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Find the first UserFavoritesProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductFindFirstArgs} args - Arguments to find a UserFavoritesProduct
     * @example
     * // Get one UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFavoritesProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFavoritesProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserFavoritesProduct'> extends True ? Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>> : Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T> | null, null>

    /**
     * Find the first UserFavoritesProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductFindFirstOrThrowArgs} args - Arguments to find a UserFavoritesProduct
     * @example
     * // Get one UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFavoritesProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFavoritesProductFindFirstOrThrowArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Find zero or more UserFavoritesProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavoritesProducts
     * const userFavoritesProducts = await prisma.userFavoritesProduct.findMany()
     * 
     * // Get first 10 UserFavoritesProducts
     * const userFavoritesProducts = await prisma.userFavoritesProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoritesProductWithIdOnly = await prisma.userFavoritesProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFavoritesProductFindManyArgs>(
      args?: SelectSubset<T, UserFavoritesProductFindManyArgs>
    ): PrismaPromise<Array<UserFavoritesProductGetPayload<T>>>

    /**
     * Create a UserFavoritesProduct.
     * @param {UserFavoritesProductCreateArgs} args - Arguments to create a UserFavoritesProduct.
     * @example
     * // Create one UserFavoritesProduct
     * const UserFavoritesProduct = await prisma.userFavoritesProduct.create({
     *   data: {
     *     // ... data to create a UserFavoritesProduct
     *   }
     * })
     * 
    **/
    create<T extends UserFavoritesProductCreateArgs>(
      args: SelectSubset<T, UserFavoritesProductCreateArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Create many UserFavoritesProducts.
     *     @param {UserFavoritesProductCreateManyArgs} args - Arguments to create many UserFavoritesProducts.
     *     @example
     *     // Create many UserFavoritesProducts
     *     const userFavoritesProduct = await prisma.userFavoritesProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserFavoritesProductCreateManyArgs>(
      args?: SelectSubset<T, UserFavoritesProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserFavoritesProduct.
     * @param {UserFavoritesProductDeleteArgs} args - Arguments to delete one UserFavoritesProduct.
     * @example
     * // Delete one UserFavoritesProduct
     * const UserFavoritesProduct = await prisma.userFavoritesProduct.delete({
     *   where: {
     *     // ... filter to delete one UserFavoritesProduct
     *   }
     * })
     * 
    **/
    delete<T extends UserFavoritesProductDeleteArgs>(
      args: SelectSubset<T, UserFavoritesProductDeleteArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Update one UserFavoritesProduct.
     * @param {UserFavoritesProductUpdateArgs} args - Arguments to update one UserFavoritesProduct.
     * @example
     * // Update one UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserFavoritesProductUpdateArgs>(
      args: SelectSubset<T, UserFavoritesProductUpdateArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Delete zero or more UserFavoritesProducts.
     * @param {UserFavoritesProductDeleteManyArgs} args - Arguments to filter UserFavoritesProducts to delete.
     * @example
     * // Delete a few UserFavoritesProducts
     * const { count } = await prisma.userFavoritesProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserFavoritesProductDeleteManyArgs>(
      args?: SelectSubset<T, UserFavoritesProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavoritesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavoritesProducts
     * const userFavoritesProduct = await prisma.userFavoritesProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserFavoritesProductUpdateManyArgs>(
      args: SelectSubset<T, UserFavoritesProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFavoritesProduct.
     * @param {UserFavoritesProductUpsertArgs} args - Arguments to update or create a UserFavoritesProduct.
     * @example
     * // Update or create a UserFavoritesProduct
     * const userFavoritesProduct = await prisma.userFavoritesProduct.upsert({
     *   create: {
     *     // ... data to create a UserFavoritesProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavoritesProduct we want to update
     *   }
     * })
    **/
    upsert<T extends UserFavoritesProductUpsertArgs>(
      args: SelectSubset<T, UserFavoritesProductUpsertArgs>
    ): Prisma__UserFavoritesProductClient<UserFavoritesProductGetPayload<T>>

    /**
     * Count the number of UserFavoritesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductCountArgs} args - Arguments to filter UserFavoritesProducts to count.
     * @example
     * // Count the number of UserFavoritesProducts
     * const count = await prisma.userFavoritesProduct.count({
     *   where: {
     *     // ... the filter for the UserFavoritesProducts we want to count
     *   }
     * })
    **/
    count<T extends UserFavoritesProductCountArgs>(
      args?: Subset<T, UserFavoritesProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoritesProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavoritesProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoritesProductAggregateArgs>(args: Subset<T, UserFavoritesProductAggregateArgs>): PrismaPromise<GetUserFavoritesProductAggregateType<T>>

    /**
     * Group by UserFavoritesProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoritesProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoritesProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoritesProductGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoritesProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoritesProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoritesProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavoritesProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserFavoritesProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserFavoritesProduct base type for findUnique actions
   */
  export type UserFavoritesProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter, which UserFavoritesProduct to fetch.
     * 
    **/
    where: UserFavoritesProductWhereUniqueInput
  }

  /**
   * UserFavoritesProduct findUnique
   */
  export interface UserFavoritesProductFindUniqueArgs extends UserFavoritesProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserFavoritesProduct findUniqueOrThrow
   */
  export type UserFavoritesProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter, which UserFavoritesProduct to fetch.
     * 
    **/
    where: UserFavoritesProductWhereUniqueInput
  }


  /**
   * UserFavoritesProduct base type for findFirst actions
   */
  export type UserFavoritesProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter, which UserFavoritesProduct to fetch.
     * 
    **/
    where?: UserFavoritesProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoritesProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserFavoritesProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavoritesProducts.
     * 
    **/
    cursor?: UserFavoritesProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoritesProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoritesProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavoritesProducts.
     * 
    **/
    distinct?: Enumerable<UserFavoritesProductScalarFieldEnum>
  }

  /**
   * UserFavoritesProduct findFirst
   */
  export interface UserFavoritesProductFindFirstArgs extends UserFavoritesProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserFavoritesProduct findFirstOrThrow
   */
  export type UserFavoritesProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter, which UserFavoritesProduct to fetch.
     * 
    **/
    where?: UserFavoritesProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoritesProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserFavoritesProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavoritesProducts.
     * 
    **/
    cursor?: UserFavoritesProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoritesProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoritesProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavoritesProducts.
     * 
    **/
    distinct?: Enumerable<UserFavoritesProductScalarFieldEnum>
  }


  /**
   * UserFavoritesProduct findMany
   */
  export type UserFavoritesProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter, which UserFavoritesProducts to fetch.
     * 
    **/
    where?: UserFavoritesProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoritesProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserFavoritesProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavoritesProducts.
     * 
    **/
    cursor?: UserFavoritesProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoritesProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoritesProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserFavoritesProductScalarFieldEnum>
  }


  /**
   * UserFavoritesProduct create
   */
  export type UserFavoritesProductCreateArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * The data needed to create a UserFavoritesProduct.
     * 
    **/
    data: XOR<UserFavoritesProductCreateInput, UserFavoritesProductUncheckedCreateInput>
  }


  /**
   * UserFavoritesProduct createMany
   */
  export type UserFavoritesProductCreateManyArgs = {
    /**
     * The data used to create many UserFavoritesProducts.
     * 
    **/
    data: Enumerable<UserFavoritesProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserFavoritesProduct update
   */
  export type UserFavoritesProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * The data needed to update a UserFavoritesProduct.
     * 
    **/
    data: XOR<UserFavoritesProductUpdateInput, UserFavoritesProductUncheckedUpdateInput>
    /**
     * Choose, which UserFavoritesProduct to update.
     * 
    **/
    where: UserFavoritesProductWhereUniqueInput
  }


  /**
   * UserFavoritesProduct updateMany
   */
  export type UserFavoritesProductUpdateManyArgs = {
    /**
     * The data used to update UserFavoritesProducts.
     * 
    **/
    data: XOR<UserFavoritesProductUpdateManyMutationInput, UserFavoritesProductUncheckedUpdateManyInput>
    /**
     * Filter which UserFavoritesProducts to update
     * 
    **/
    where?: UserFavoritesProductWhereInput
  }


  /**
   * UserFavoritesProduct upsert
   */
  export type UserFavoritesProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * The filter to search for the UserFavoritesProduct to update in case it exists.
     * 
    **/
    where: UserFavoritesProductWhereUniqueInput
    /**
     * In case the UserFavoritesProduct found by the `where` argument doesn't exist, create a new UserFavoritesProduct with this data.
     * 
    **/
    create: XOR<UserFavoritesProductCreateInput, UserFavoritesProductUncheckedCreateInput>
    /**
     * In case the UserFavoritesProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserFavoritesProductUpdateInput, UserFavoritesProductUncheckedUpdateInput>
  }


  /**
   * UserFavoritesProduct delete
   */
  export type UserFavoritesProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
    /**
     * Filter which UserFavoritesProduct to delete.
     * 
    **/
    where: UserFavoritesProductWhereUniqueInput
  }


  /**
   * UserFavoritesProduct deleteMany
   */
  export type UserFavoritesProductDeleteManyArgs = {
    /**
     * Filter which UserFavoritesProducts to delete
     * 
    **/
    where?: UserFavoritesProductWhereInput
  }


  /**
   * UserFavoritesProduct without action
   */
  export type UserFavoritesProductArgs = {
    /**
     * Select specific fields to fetch from the UserFavoritesProduct
     * 
    **/
    select?: UserFavoritesProductSelect | null
  }



  /**
   * Model Vote
   */


  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _avg: VoteAvgAggregateOutputType | null
    _sum: VoteSumAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteAvgAggregateOutputType = {
    id: number | null
    count_votes: number | null
  }

  export type VoteSumAggregateOutputType = {
    id: number | null
    count_votes: number | null
  }

  export type VoteMinAggregateOutputType = {
    id: number | null
    count_votes: number | null
    is_vote_user: boolean | null
    productId: string | null
    userId: string | null
  }

  export type VoteMaxAggregateOutputType = {
    id: number | null
    count_votes: number | null
    is_vote_user: boolean | null
    productId: string | null
    userId: string | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    count_votes: number
    is_vote_user: number
    productId: number
    userId: number
    _all: number
  }


  export type VoteAvgAggregateInputType = {
    id?: true
    count_votes?: true
  }

  export type VoteSumAggregateInputType = {
    id?: true
    count_votes?: true
  }

  export type VoteMinAggregateInputType = {
    id?: true
    count_votes?: true
    is_vote_user?: true
    productId?: true
    userId?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    count_votes?: true
    is_vote_user?: true
    productId?: true
    userId?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    count_votes?: true
    is_vote_user?: true
    productId?: true
    userId?: true
    _all?: true
  }

  export type VoteAggregateArgs = {
    /**
     * Filter which Vote to aggregate.
     * 
    **/
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     * 
    **/
    orderBy?: Enumerable<VoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs = {
    where?: VoteWhereInput
    orderBy?: Enumerable<VoteOrderByWithAggregationInput>
    by: Array<VoteScalarFieldEnum>
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _avg?: VoteAvgAggregateInputType
    _sum?: VoteSumAggregateInputType
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }


  export type VoteGroupByOutputType = {
    id: number
    count_votes: number
    is_vote_user: boolean
    productId: string | null
    userId: string | null
    _count: VoteCountAggregateOutputType | null
    _avg: VoteAvgAggregateOutputType | null
    _sum: VoteSumAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect = {
    id?: boolean
    count_votes?: boolean
    is_vote_user?: boolean
    productId?: boolean
    userId?: boolean
  }


  export type VoteGetPayload<S extends boolean | null | undefined | VoteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Vote :
    S extends undefined ? never :
    S extends { include: any } & (VoteArgs | VoteFindManyArgs)
    ? Vote 
    : S extends { select: any } & (VoteArgs | VoteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Vote ? Vote[P] : never
  } 
      : Vote


  type VoteCountArgs = Merge<
    Omit<VoteFindManyArgs, 'select' | 'include'> & {
      select?: VoteCountAggregateInputType | true
    }
  >

  export interface VoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vote'> extends True ? Prisma__VoteClient<VoteGetPayload<T>> : Prisma__VoteClient<VoteGetPayload<T> | null, null>

    /**
     * Find one Vote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VoteFindUniqueOrThrowArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vote'> extends True ? Prisma__VoteClient<VoteGetPayload<T>> : Prisma__VoteClient<VoteGetPayload<T> | null, null>

    /**
     * Find the first Vote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VoteFindFirstOrThrowArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VoteFindManyArgs>(
      args?: SelectSubset<T, VoteFindManyArgs>
    ): PrismaPromise<Array<VoteGetPayload<T>>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
    **/
    create<T extends VoteCreateArgs>(
      args: SelectSubset<T, VoteCreateArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Create many Votes.
     *     @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     *     @example
     *     // Create many Votes
     *     const vote = await prisma.vote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VoteCreateManyArgs>(
      args?: SelectSubset<T, VoteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
    **/
    delete<T extends VoteDeleteArgs>(
      args: SelectSubset<T, VoteDeleteArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VoteUpdateArgs>(
      args: SelectSubset<T, VoteUpdateArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VoteDeleteManyArgs>(
      args?: SelectSubset<T, VoteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VoteUpdateManyArgs>(
      args: SelectSubset<T, VoteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
    **/
    upsert<T extends VoteUpsertArgs>(
      args: SelectSubset<T, VoteUpsertArgs>
    ): Prisma__VoteClient<VoteGetPayload<T>>

    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VoteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vote base type for findUnique actions
   */
  export type VoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter, which Vote to fetch.
     * 
    **/
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUnique
   */
  export interface VoteFindUniqueArgs extends VoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter, which Vote to fetch.
     * 
    **/
    where: VoteWhereUniqueInput
  }


  /**
   * Vote base type for findFirst actions
   */
  export type VoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter, which Vote to fetch.
     * 
    **/
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     * 
    **/
    orderBy?: Enumerable<VoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     * 
    **/
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     * 
    **/
    distinct?: Enumerable<VoteScalarFieldEnum>
  }

  /**
   * Vote findFirst
   */
  export interface VoteFindFirstArgs extends VoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter, which Vote to fetch.
     * 
    **/
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     * 
    **/
    orderBy?: Enumerable<VoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     * 
    **/
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     * 
    **/
    distinct?: Enumerable<VoteScalarFieldEnum>
  }


  /**
   * Vote findMany
   */
  export type VoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter, which Votes to fetch.
     * 
    **/
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     * 
    **/
    orderBy?: Enumerable<VoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     * 
    **/
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VoteScalarFieldEnum>
  }


  /**
   * Vote create
   */
  export type VoteCreateArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * The data needed to create a Vote.
     * 
    **/
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }


  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs = {
    /**
     * The data used to create many Votes.
     * 
    **/
    data: Enumerable<VoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vote update
   */
  export type VoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * The data needed to update a Vote.
     * 
    **/
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     * 
    **/
    where: VoteWhereUniqueInput
  }


  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs = {
    /**
     * The data used to update Votes.
     * 
    **/
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     * 
    **/
    where?: VoteWhereInput
  }


  /**
   * Vote upsert
   */
  export type VoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * The filter to search for the Vote to update in case it exists.
     * 
    **/
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     * 
    **/
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }


  /**
   * Vote delete
   */
  export type VoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
    /**
     * Filter which Vote to delete.
     * 
    **/
    where: VoteWhereUniqueInput
  }


  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs = {
    /**
     * Filter which Votes to delete
     * 
    **/
    where?: VoteWhereInput
  }


  /**
   * Vote without action
   */
  export type VoteArgs = {
    /**
     * Select specific fields to fetch from the Vote
     * 
    **/
    select?: VoteSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    compoundId: 'compoundId',
    userId: 'userId',
    providerType: 'providerType',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    accessTokenExpires: 'accessTokenExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    zip: 'zip',
    deliveryId: 'deliveryId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const AuthorProductScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    first_name: 'first_name',
    last_name: 'last_name',
    is_subscribed: 'is_subscribed',
    phone_user: 'phone_user',
    trademark: 'trademark',
    locale_user: 'locale_user',
    image_url_user: 'image_url_user',
    image_file_user: 'image_file_user',
    auth_is_telegram: 'auth_is_telegram',
    auth_is_yandex: 'auth_is_yandex',
    auth_is_google: 'auth_is_google',
    is_admin_constructor: 'is_admin_constructor'
  };

  export type AuthorProductScalarFieldEnum = (typeof AuthorProductScalarFieldEnum)[keyof typeof AuthorProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    productId: 'productId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressId: 'addressId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    body: 'body',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    purchaseDate: 'purchaseDate',
    description: 'description',
    userId: 'userId',
    productId: 'productId',
    deliveryId: 'deliveryId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const Payments_productbuyersScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    backUrl: 'backUrl',
    companyName: 'companyName',
    details: 'details',
    emailReq: 'emailReq',
    errorCode: 'errorCode',
    merchantEmail: 'merchantEmail',
    merchantName: 'merchantName',
    message: 'message',
    orderId: 'orderId',
    paymentId: 'paymentId',
    phoneReq: 'phoneReq',
    success: 'success',
    tranDate: 'tranDate'
  };

  export type Payments_productbuyersScalarFieldEnum = (typeof Payments_productbuyersScalarFieldEnum)[keyof typeof Payments_productbuyersScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    sku: 'sku',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Product_categoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Product_categoryScalarFieldEnum = (typeof Product_categoryScalarFieldEnum)[keyof typeof Product_categoryScalarFieldEnum]


  export const ProductsProductResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    image: 'image',
    text: 'text',
    price_product: 'price_product',
    taxation: 'taxation',
    tax: 'tax',
    authorProductId: 'authorProductId',
    productsProductId: 'productsProductId'
  };

  export type ProductsProductResultScalarFieldEnum = (typeof ProductsProductResultScalarFieldEnum)[keyof typeof ProductsProductResultScalarFieldEnum]


  export const ProductsProductScalarFieldEnum: {
    id: 'id',
    count: 'count',
    next: 'next',
    previous: 'previous'
  };

  export type ProductsProductScalarFieldEnum = (typeof ProductsProductScalarFieldEnum)[keyof typeof ProductsProductScalarFieldEnum]


  export const ProductsProductWhoLikesItScalarFieldEnum: {
    id: 'id',
    product_id: 'product_id',
    user_id: 'user_id'
  };

  export type ProductsProductWhoLikesItScalarFieldEnum = (typeof ProductsProductWhoLikesItScalarFieldEnum)[keyof typeof ProductsProductWhoLikesItScalarFieldEnum]


  export const Products_product_categoryScalarFieldEnum: {
    id: 'id',
    product_id: 'product_id',
    category_id: 'category_id'
  };

  export type Products_product_categoryScalarFieldEnum = (typeof Products_product_categoryScalarFieldEnum)[keyof typeof Products_product_categoryScalarFieldEnum]


  export const Products_product_tagsScalarFieldEnum: {
    id: 'id',
    producy_id: 'producy_id',
    tag_id: 'tag_id'
  };

  export type Products_product_tagsScalarFieldEnum = (typeof Products_product_tagsScalarFieldEnum)[keyof typeof Products_product_tagsScalarFieldEnum]


  export const Products_tagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    slug: 'slug',
    key: 'key'
  };

  export type Products_tagScalarFieldEnum = (typeof Products_tagScalarFieldEnum)[keyof typeof Products_tagScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expires: 'expires',
    sessionToken: 'sessionToken',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    slug: 'slug',
    productsProductResultId: 'productsProductResultId'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserFavoritesProductScalarFieldEnum: {
    id: 'id',
    is_favorite: 'is_favorite',
    userId: 'userId',
    productId: 'productId'
  };

  export type UserFavoritesProductScalarFieldEnum = (typeof UserFavoritesProductScalarFieldEnum)[keyof typeof UserFavoritesProductScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    first_name: 'first_name',
    last_name: 'last_name',
    phone_user: 'phone_user',
    trademark: 'trademark',
    locale_user: 'locale_user',
    image_url_user: 'image_url_user',
    auth_is_telegram: 'auth_is_telegram',
    auth_is_yandex: 'auth_is_yandex',
    auth_is_google: 'auth_is_google',
    role: 'role',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailDateVerified: 'emailDateVerified'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationRequestScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type VerificationRequestScalarFieldEnum = (typeof VerificationRequestScalarFieldEnum)[keyof typeof VerificationRequestScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    count_votes: 'count_votes',
    is_vote_user: 'is_vote_user',
    productId: 'productId',
    userId: 'userId'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: IntFilter | number
    body?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = {
    id?: number
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    body?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: IntFilter | number
    compoundId?: StringFilter | string
    userId?: StringFilter | string
    providerType?: StringFilter | string
    providerId?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    accessTokenExpires?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: number
    compoundId?: string
    providerId_providerAccountId?: AccountProviderIdProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    compoundId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    providerType?: StringWithAggregatesFilter | string
    providerId?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    accessToken?: StringNullableWithAggregatesFilter | string | null
    accessTokenExpires?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    sessionToken?: StringFilter | string
    accessToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = {
    id?: number
    sessionToken?: string
    accessToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
    sessionToken?: StringWithAggregatesFilter | string
    accessToken?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    addressId?: IntNullableFilter | number | null
    Address?: XOR<AddressRelationFilter, AddressWhereInput> | null
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    Address?: AddressOrderByWithRelationInput
  }

  export type CityWhereUniqueInput = {
    id?: number
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    addressId?: IntNullableWithAggregatesFilter | number | null
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: IntFilter | number
    zip?: IntFilter | number
    deliveryId?: IntNullableFilter | number | null
    Delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput> | null
    city?: CityListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
    Delivery?: DeliveryOrderByWithRelationInput
    city?: CityOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = {
    id?: number
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    zip?: IntWithAggregatesFilter | number
    deliveryId?: IntNullableWithAggregatesFilter | number | null
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    productId?: StringNullableFilter | string | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: number
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    productId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    image?: StringFilter | string
    sku?: StringFilter | string
    quantity?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    categories?: CategoryListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    categories?: CategoryOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
    sku?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    sku?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type DeliveryWhereInput = {
    AND?: Enumerable<DeliveryWhereInput>
    OR?: Enumerable<DeliveryWhereInput>
    NOT?: Enumerable<DeliveryWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    address?: AddressListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type DeliveryWhereUniqueInput = {
    id?: number
  }

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
  }

  export type VerificationRequestWhereInput = {
    AND?: Enumerable<VerificationRequestWhereInput>
    OR?: Enumerable<VerificationRequestWhereInput>
    NOT?: Enumerable<VerificationRequestWhereInput>
    id?: IntFilter | number
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    userVerification?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VerificationRequestOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    userVerification?: UserOrderByWithRelationInput
  }

  export type VerificationRequestWhereUniqueInput = {
    id?: number
    token?: string
  }

  export type VerificationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: VerificationRequestCountOrderByAggregateInput
    _avg?: VerificationRequestAvgOrderByAggregateInput
    _max?: VerificationRequestMaxOrderByAggregateInput
    _min?: VerificationRequestMinOrderByAggregateInput
    _sum?: VerificationRequestSumOrderByAggregateInput
  }

  export type VerificationRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
  }

  export type product_categoryWhereInput = {
    AND?: Enumerable<product_categoryWhereInput>
    OR?: Enumerable<product_categoryWhereInput>
    NOT?: Enumerable<product_categoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type product_categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type product_categoryWhereUniqueInput = {
    id?: number
  }

  export type product_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: product_categoryCountOrderByAggregateInput
    _avg?: product_categoryAvgOrderByAggregateInput
    _max?: product_categoryMaxOrderByAggregateInput
    _min?: product_categoryMinOrderByAggregateInput
    _sum?: product_categorySumOrderByAggregateInput
  }

  export type product_categoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<product_categoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<product_categoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<product_categoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    username?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    phone_user?: StringNullableFilter | string | null
    trademark?: StringNullableFilter | string | null
    locale_user?: StringNullableFilter | string | null
    image_url_user?: StringNullableFilter | string | null
    auth_is_telegram?: BoolFilter | boolean
    auth_is_yandex?: BoolFilter | boolean
    auth_is_google?: BoolFilter | boolean
    role?: StringFilter | string
    bio?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    emailDateVerified?: DateTimeNullableFilter | Date | string | null
    messages?: MessageListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    verifiedUsers?: VerificationRequestListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailDateVerified?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    verifiedUsers?: VerificationRequestOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailDateVerified?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    phone_user?: StringNullableWithAggregatesFilter | string | null
    trademark?: StringNullableWithAggregatesFilter | string | null
    locale_user?: StringNullableWithAggregatesFilter | string | null
    image_url_user?: StringNullableWithAggregatesFilter | string | null
    auth_is_telegram?: BoolWithAggregatesFilter | boolean
    auth_is_yandex?: BoolWithAggregatesFilter | boolean
    auth_is_google?: BoolWithAggregatesFilter | boolean
    role?: StringWithAggregatesFilter | string
    bio?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    emailDateVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductsProductWhereInput = {
    AND?: Enumerable<ProductsProductWhereInput>
    OR?: Enumerable<ProductsProductWhereInput>
    NOT?: Enumerable<ProductsProductWhereInput>
    id?: StringFilter | string
    count?: IntFilter | number
    next?: IntFilter | number
    previous?: IntFilter | number
    results?: ProductsProductResultListRelationFilter
  }

  export type ProductsProductOrderByWithRelationInput = {
    id?: SortOrder
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
    results?: ProductsProductResultOrderByRelationAggregateInput
  }

  export type ProductsProductWhereUniqueInput = {
    id?: string
  }

  export type ProductsProductOrderByWithAggregationInput = {
    id?: SortOrder
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
    _count?: ProductsProductCountOrderByAggregateInput
    _avg?: ProductsProductAvgOrderByAggregateInput
    _max?: ProductsProductMaxOrderByAggregateInput
    _min?: ProductsProductMinOrderByAggregateInput
    _sum?: ProductsProductSumOrderByAggregateInput
  }

  export type ProductsProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductsProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductsProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductsProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    count?: IntWithAggregatesFilter | number
    next?: IntWithAggregatesFilter | number
    previous?: IntWithAggregatesFilter | number
  }

  export type ProductsProductResultWhereInput = {
    AND?: Enumerable<ProductsProductResultWhereInput>
    OR?: Enumerable<ProductsProductResultWhereInput>
    NOT?: Enumerable<ProductsProductResultWhereInput>
    id?: StringFilter | string
    tags?: TagsListRelationFilter
    author?: XOR<AuthorProductRelationFilter, AuthorProductWhereInput> | null
    userId?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    price_product?: IntNullableFilter | number | null
    taxation?: StringNullableFilter | string | null
    tax?: StringNullableFilter | string | null
    authorProductId?: StringNullableFilter | string | null
    productsProductId?: StringNullableFilter | string | null
    productsProduct?: ProductsProductListRelationFilter
  }

  export type ProductsProductResultOrderByWithRelationInput = {
    id?: SortOrder
    tags?: TagsOrderByRelationAggregateInput
    author?: AuthorProductOrderByWithRelationInput
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    text?: SortOrder
    price_product?: SortOrder
    taxation?: SortOrder
    tax?: SortOrder
    authorProductId?: SortOrder
    productsProductId?: SortOrder
    productsProduct?: ProductsProductOrderByRelationAggregateInput
  }

  export type ProductsProductResultWhereUniqueInput = {
    id?: string
  }

  export type ProductsProductResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    text?: SortOrder
    price_product?: SortOrder
    taxation?: SortOrder
    tax?: SortOrder
    authorProductId?: SortOrder
    productsProductId?: SortOrder
    _count?: ProductsProductResultCountOrderByAggregateInput
    _avg?: ProductsProductResultAvgOrderByAggregateInput
    _max?: ProductsProductResultMaxOrderByAggregateInput
    _min?: ProductsProductResultMinOrderByAggregateInput
    _sum?: ProductsProductResultSumOrderByAggregateInput
  }

  export type ProductsProductResultScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductsProductResultScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductsProductResultScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductsProductResultScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    text?: StringNullableWithAggregatesFilter | string | null
    price_product?: IntNullableWithAggregatesFilter | number | null
    taxation?: StringNullableWithAggregatesFilter | string | null
    tax?: StringNullableWithAggregatesFilter | string | null
    authorProductId?: StringNullableWithAggregatesFilter | string | null
    productsProductId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    order_id?: StringFilter | string
    purchaseDate?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: StringFilter | string
    productId?: StringFilter | string
    deliveryId?: IntNullableFilter | number | null
    Delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput> | null
    products?: ProductListRelationFilter
    customer?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    purchaseDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    deliveryId?: SortOrder
    Delivery?: DeliveryOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    customer?: UserOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    purchaseDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    deliveryId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_id?: StringWithAggregatesFilter | string
    purchaseDate?: DateTimeWithAggregatesFilter | Date | string
    description?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    deliveryId?: IntNullableWithAggregatesFilter | number | null
  }

  export type products_product_categoryWhereInput = {
    AND?: Enumerable<products_product_categoryWhereInput>
    OR?: Enumerable<products_product_categoryWhereInput>
    NOT?: Enumerable<products_product_categoryWhereInput>
    id?: IntFilter | number
    product_id?: IntFilter | number
    category_id?: IntFilter | number
  }

  export type products_product_categoryOrderByWithRelationInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_product_categoryWhereUniqueInput = {
    id?: number
  }

  export type products_product_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
    _count?: products_product_categoryCountOrderByAggregateInput
    _avg?: products_product_categoryAvgOrderByAggregateInput
    _max?: products_product_categoryMaxOrderByAggregateInput
    _min?: products_product_categoryMinOrderByAggregateInput
    _sum?: products_product_categorySumOrderByAggregateInput
  }

  export type products_product_categoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<products_product_categoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<products_product_categoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<products_product_categoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    product_id?: IntWithAggregatesFilter | number
    category_id?: IntWithAggregatesFilter | number
  }

  export type products_tagWhereInput = {
    AND?: Enumerable<products_tagWhereInput>
    OR?: Enumerable<products_tagWhereInput>
    NOT?: Enumerable<products_tagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    color?: StringFilter | string
    slug?: StringFilter | string
    key?: IntNullableFilter | number | null
  }

  export type products_tagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    key?: SortOrder
  }

  export type products_tagWhereUniqueInput = {
    id?: number
  }

  export type products_tagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    key?: SortOrder
    _count?: products_tagCountOrderByAggregateInput
    _avg?: products_tagAvgOrderByAggregateInput
    _max?: products_tagMaxOrderByAggregateInput
    _min?: products_tagMinOrderByAggregateInput
    _sum?: products_tagSumOrderByAggregateInput
  }

  export type products_tagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<products_tagScalarWhereWithAggregatesInput>
    OR?: Enumerable<products_tagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<products_tagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    color?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    key?: IntNullableWithAggregatesFilter | number | null
  }

  export type products_product_tagsWhereInput = {
    AND?: Enumerable<products_product_tagsWhereInput>
    OR?: Enumerable<products_product_tagsWhereInput>
    NOT?: Enumerable<products_product_tagsWhereInput>
    id?: IntFilter | number
    producy_id?: IntFilter | number
    tag_id?: IntFilter | number
  }

  export type products_product_tagsOrderByWithRelationInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type products_product_tagsWhereUniqueInput = {
    id?: number
  }

  export type products_product_tagsOrderByWithAggregationInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
    _count?: products_product_tagsCountOrderByAggregateInput
    _avg?: products_product_tagsAvgOrderByAggregateInput
    _max?: products_product_tagsMaxOrderByAggregateInput
    _min?: products_product_tagsMinOrderByAggregateInput
    _sum?: products_product_tagsSumOrderByAggregateInput
  }

  export type products_product_tagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<products_product_tagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<products_product_tagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<products_product_tagsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    producy_id?: IntWithAggregatesFilter | number
    tag_id?: IntWithAggregatesFilter | number
  }

  export type ProductsProductWhoLikesItWhereInput = {
    AND?: Enumerable<ProductsProductWhoLikesItWhereInput>
    OR?: Enumerable<ProductsProductWhoLikesItWhereInput>
    NOT?: Enumerable<ProductsProductWhoLikesItWhereInput>
    id?: IntFilter | number
    product_id?: IntFilter | number
    user_id?: IntFilter | number
  }

  export type ProductsProductWhoLikesItOrderByWithRelationInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProductsProductWhoLikesItWhereUniqueInput = {
    id?: number
  }

  export type ProductsProductWhoLikesItOrderByWithAggregationInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    _count?: ProductsProductWhoLikesItCountOrderByAggregateInput
    _avg?: ProductsProductWhoLikesItAvgOrderByAggregateInput
    _max?: ProductsProductWhoLikesItMaxOrderByAggregateInput
    _min?: ProductsProductWhoLikesItMinOrderByAggregateInput
    _sum?: ProductsProductWhoLikesItSumOrderByAggregateInput
  }

  export type ProductsProductWhoLikesItScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductsProductWhoLikesItScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductsProductWhoLikesItScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductsProductWhoLikesItScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    product_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
  }

  export type payments_productbuyersWhereInput = {
    AND?: Enumerable<payments_productbuyersWhereInput>
    OR?: Enumerable<payments_productbuyersWhereInput>
    NOT?: Enumerable<payments_productbuyersWhereInput>
    id?: StringFilter | string
    amount?: IntFilter | number
    backUrl?: StringNullableFilter | string | null
    companyName?: StringNullableFilter | string | null
    details?: StringNullableFilter | string | null
    emailReq?: StringNullableFilter | string | null
    errorCode?: StringNullableFilter | string | null
    merchantEmail?: StringNullableFilter | string | null
    merchantName?: StringNullableFilter | string | null
    message?: StringNullableFilter | string | null
    orderId?: StringFilter | string
    paymentId?: StringFilter | string
    phoneReq?: StringNullableFilter | string | null
    success?: StringNullableFilter | string | null
    tranDate?: StringNullableFilter | string | null
  }

  export type payments_productbuyersOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    backUrl?: SortOrder
    companyName?: SortOrder
    details?: SortOrder
    emailReq?: SortOrder
    errorCode?: SortOrder
    merchantEmail?: SortOrder
    merchantName?: SortOrder
    message?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    phoneReq?: SortOrder
    success?: SortOrder
    tranDate?: SortOrder
  }

  export type payments_productbuyersWhereUniqueInput = {
    id?: string
  }

  export type payments_productbuyersOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    backUrl?: SortOrder
    companyName?: SortOrder
    details?: SortOrder
    emailReq?: SortOrder
    errorCode?: SortOrder
    merchantEmail?: SortOrder
    merchantName?: SortOrder
    message?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    phoneReq?: SortOrder
    success?: SortOrder
    tranDate?: SortOrder
    _count?: payments_productbuyersCountOrderByAggregateInput
    _avg?: payments_productbuyersAvgOrderByAggregateInput
    _max?: payments_productbuyersMaxOrderByAggregateInput
    _min?: payments_productbuyersMinOrderByAggregateInput
    _sum?: payments_productbuyersSumOrderByAggregateInput
  }

  export type payments_productbuyersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<payments_productbuyersScalarWhereWithAggregatesInput>
    OR?: Enumerable<payments_productbuyersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<payments_productbuyersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: IntWithAggregatesFilter | number
    backUrl?: StringNullableWithAggregatesFilter | string | null
    companyName?: StringNullableWithAggregatesFilter | string | null
    details?: StringNullableWithAggregatesFilter | string | null
    emailReq?: StringNullableWithAggregatesFilter | string | null
    errorCode?: StringNullableWithAggregatesFilter | string | null
    merchantEmail?: StringNullableWithAggregatesFilter | string | null
    merchantName?: StringNullableWithAggregatesFilter | string | null
    message?: StringNullableWithAggregatesFilter | string | null
    orderId?: StringWithAggregatesFilter | string
    paymentId?: StringWithAggregatesFilter | string
    phoneReq?: StringNullableWithAggregatesFilter | string | null
    success?: StringNullableWithAggregatesFilter | string | null
    tranDate?: StringNullableWithAggregatesFilter | string | null
  }

  export type AuthorProductWhereInput = {
    AND?: Enumerable<AuthorProductWhereInput>
    OR?: Enumerable<AuthorProductWhereInput>
    NOT?: Enumerable<AuthorProductWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    username?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    is_subscribed?: BoolNullableFilter | boolean | null
    phone_user?: StringNullableFilter | string | null
    trademark?: StringNullableFilter | string | null
    locale_user?: StringNullableFilter | string | null
    image_url_user?: StringNullableFilter | string | null
    image_file_user?: StringNullableFilter | string | null
    auth_is_telegram?: BoolFilter | boolean
    auth_is_yandex?: BoolFilter | boolean
    auth_is_google?: BoolFilter | boolean
    is_admin_constructor?: BoolFilter | boolean
    ProductsProductResult?: ProductsProductResultListRelationFilter
  }

  export type AuthorProductOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_subscribed?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    image_file_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    is_admin_constructor?: SortOrder
    ProductsProductResult?: ProductsProductResultOrderByRelationAggregateInput
  }

  export type AuthorProductWhereUniqueInput = {
    id?: string
  }

  export type AuthorProductOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_subscribed?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    image_file_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    is_admin_constructor?: SortOrder
    _count?: AuthorProductCountOrderByAggregateInput
    _max?: AuthorProductMaxOrderByAggregateInput
    _min?: AuthorProductMinOrderByAggregateInput
  }

  export type AuthorProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthorProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthorProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthorProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    is_subscribed?: BoolNullableWithAggregatesFilter | boolean | null
    phone_user?: StringNullableWithAggregatesFilter | string | null
    trademark?: StringNullableWithAggregatesFilter | string | null
    locale_user?: StringNullableWithAggregatesFilter | string | null
    image_url_user?: StringNullableWithAggregatesFilter | string | null
    image_file_user?: StringNullableWithAggregatesFilter | string | null
    auth_is_telegram?: BoolWithAggregatesFilter | boolean
    auth_is_yandex?: BoolWithAggregatesFilter | boolean
    auth_is_google?: BoolWithAggregatesFilter | boolean
    is_admin_constructor?: BoolWithAggregatesFilter | boolean
  }

  export type TagsWhereInput = {
    AND?: Enumerable<TagsWhereInput>
    OR?: Enumerable<TagsWhereInput>
    NOT?: Enumerable<TagsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    ProductsProductResult?: ProductsProductResultListRelationFilter
    productsProductResultId?: IntNullableFilter | number | null
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    ProductsProductResult?: ProductsProductResultOrderByRelationAggregateInput
    productsProductResultId?: SortOrder
  }

  export type TagsWhereUniqueInput = {
    id?: number
  }

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    productsProductResultId?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _avg?: TagsAvgOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
    _sum?: TagsSumOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    color?: StringNullableWithAggregatesFilter | string | null
    slug?: StringNullableWithAggregatesFilter | string | null
    productsProductResultId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserFavoritesProductWhereInput = {
    AND?: Enumerable<UserFavoritesProductWhereInput>
    OR?: Enumerable<UserFavoritesProductWhereInput>
    NOT?: Enumerable<UserFavoritesProductWhereInput>
    id?: IntFilter | number
    is_favorite?: BoolFilter | boolean
    userId?: StringFilter | string
    productId?: StringFilter | string
  }

  export type UserFavoritesProductOrderByWithRelationInput = {
    id?: SortOrder
    is_favorite?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type UserFavoritesProductWhereUniqueInput = {
    id?: number
    userId_productId?: UserFavoritesProductUserIdProductIdCompoundUniqueInput
  }

  export type UserFavoritesProductOrderByWithAggregationInput = {
    id?: SortOrder
    is_favorite?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    _count?: UserFavoritesProductCountOrderByAggregateInput
    _avg?: UserFavoritesProductAvgOrderByAggregateInput
    _max?: UserFavoritesProductMaxOrderByAggregateInput
    _min?: UserFavoritesProductMinOrderByAggregateInput
    _sum?: UserFavoritesProductSumOrderByAggregateInput
  }

  export type UserFavoritesProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserFavoritesProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserFavoritesProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserFavoritesProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    is_favorite?: BoolWithAggregatesFilter | boolean
    userId?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
  }

  export type VoteWhereInput = {
    AND?: Enumerable<VoteWhereInput>
    OR?: Enumerable<VoteWhereInput>
    NOT?: Enumerable<VoteWhereInput>
    id?: IntFilter | number
    count_votes?: IntFilter | number
    is_vote_user?: BoolFilter | boolean
    productId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    count_votes?: SortOrder
    is_vote_user?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type VoteWhereUniqueInput = {
    id?: number
    userId_productId?: VoteUserIdProductIdCompoundUniqueInput
  }

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    count_votes?: SortOrder
    is_vote_user?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _avg?: VoteAvgOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
    _sum?: VoteSumOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<VoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VoteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    count_votes?: IntWithAggregatesFilter | number
    is_vote_user?: BoolWithAggregatesFilter | boolean
    productId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MessageCreateInput = {
    body: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    body: string
    createdAt?: Date | string
    userId: string
  }

  export type MessageUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: number
    body: string
    createdAt?: Date | string
    userId: string
  }

  export type MessageUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    compoundId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    compoundId: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    compoundId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: number
    compoundId: string
    userId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    compoundId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: string
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    name: string
    Address?: AddressCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    addressId?: number | null
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Address?: AddressUpdateOneWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
    addressId?: number | null
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressCreateInput = {
    zip: number
    Delivery?: DeliveryCreateNestedOneWithoutAddressInput
    city?: CityCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    zip: number
    deliveryId?: number | null
    city?: CityUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    zip?: IntFieldUpdateOperationsInput | number
    Delivery?: DeliveryUpdateOneWithoutAddressNestedInput
    city?: CityUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    zip?: IntFieldUpdateOperationsInput | number
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    city?: CityUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    zip: number
    deliveryId?: number | null
  }

  export type AddressUpdateManyMutationInput = {
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    zip?: IntFieldUpdateOperationsInput | number
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    name: string
    productId?: string | null
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    productId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    productId?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryCreateInput = {
    title: string
    address?: AddressCreateNestedManyWithoutDeliveryInput
    orders?: OrderCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: number
    title: string
    address?: AddressUncheckedCreateNestedManyWithoutDeliveryInput
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutDeliveryNestedInput
    orders?: OrderUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutDeliveryNestedInput
    orders?: OrderUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: number
    title: string
  }

  export type DeliveryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationRequestCreateInput = {
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userVerification: UserCreateNestedOneWithoutVerifiedUsersInput
  }

  export type VerificationRequestUncheckedCreateInput = {
    id?: number
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type VerificationRequestUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userVerification?: UserUpdateOneRequiredWithoutVerifiedUsersNestedInput
  }

  export type VerificationRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationRequestCreateManyInput = {
    id?: number
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type VerificationRequestUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryCreateInput = {
    name: string
  }

  export type product_categoryUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type product_categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryCreateManyInput = {
    id?: number
    name: string
  }

  export type product_categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    products?: ProductCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductsProductCreateInput = {
    id?: string
    count: number
    next: number
    previous: number
    results?: ProductsProductResultCreateNestedManyWithoutProductsProductInput
  }

  export type ProductsProductUncheckedCreateInput = {
    id?: string
    count: number
    next: number
    previous: number
    results?: ProductsProductResultUncheckedCreateNestedManyWithoutProductsProductInput
  }

  export type ProductsProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
    results?: ProductsProductResultUpdateManyWithoutProductsProductNestedInput
  }

  export type ProductsProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
    results?: ProductsProductResultUncheckedUpdateManyWithoutProductsProductNestedInput
  }

  export type ProductsProductCreateManyInput = {
    id?: string
    count: number
    next: number
    previous: number
  }

  export type ProductsProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductResultCreateInput = {
    id?: string
    tags?: TagsCreateNestedManyWithoutProductsProductResultInput
    author?: AuthorProductCreateNestedOneWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultUncheckedCreateInput = {
    id?: string
    tags?: TagsUncheckedCreateNestedManyWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    authorProductId?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductUncheckedCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUpdateManyWithoutProductsProductResultNestedInput
    author?: AuthorProductUpdateOneWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUpdateManyWithoutResultsNestedInput
  }

  export type ProductsProductResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUncheckedUpdateManyWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    authorProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUncheckedUpdateManyWithoutResultsNestedInput
  }

  export type ProductsProductResultCreateManyInput = {
    id?: string
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    authorProductId?: string | null
    productsProductId?: string | null
  }

  export type ProductsProductResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsProductResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    authorProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    Delivery?: DeliveryCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    customer?: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    userId: string
    productId: string
    deliveryId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    Delivery?: DeliveryUpdateOneWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    customer?: UserUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    userId: string
    productId: string
    deliveryId?: number | null
  }

  export type OrderUpdateManyMutationInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_product_categoryCreateInput = {
    product_id: number
    category_id: number
  }

  export type products_product_categoryUncheckedCreateInput = {
    id?: number
    product_id: number
    category_id: number
  }

  export type products_product_categoryUpdateInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_categoryCreateManyInput = {
    id?: number
    product_id: number
    category_id: number
  }

  export type products_product_categoryUpdateManyMutationInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_tagCreateInput = {
    name: string
    color: string
    slug: string
    key?: number | null
  }

  export type products_tagUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    slug: string
    key?: number | null
  }

  export type products_tagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    key?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_tagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    key?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_tagCreateManyInput = {
    id?: number
    name: string
    color: string
    slug: string
    key?: number | null
  }

  export type products_tagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    key?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_tagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    key?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_product_tagsCreateInput = {
    producy_id: number
    tag_id: number
  }

  export type products_product_tagsUncheckedCreateInput = {
    id?: number
    producy_id: number
    tag_id: number
  }

  export type products_product_tagsUpdateInput = {
    producy_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_tagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    producy_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_tagsCreateManyInput = {
    id?: number
    producy_id: number
    tag_id: number
  }

  export type products_product_tagsUpdateManyMutationInput = {
    producy_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type products_product_tagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    producy_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductWhoLikesItCreateInput = {
    product_id: number
    user_id: number
  }

  export type ProductsProductWhoLikesItUncheckedCreateInput = {
    id?: number
    product_id: number
    user_id: number
  }

  export type ProductsProductWhoLikesItUpdateInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductWhoLikesItUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductWhoLikesItCreateManyInput = {
    id?: number
    product_id: number
    user_id: number
  }

  export type ProductsProductWhoLikesItUpdateManyMutationInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductWhoLikesItUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type payments_productbuyersCreateInput = {
    id?: string
    amount: number
    backUrl?: string | null
    companyName?: string | null
    details?: string | null
    emailReq?: string | null
    errorCode?: string | null
    merchantEmail?: string | null
    merchantName?: string | null
    message?: string | null
    orderId: string
    paymentId: string
    phoneReq?: string | null
    success?: string | null
    tranDate?: string | null
  }

  export type payments_productbuyersUncheckedCreateInput = {
    id?: string
    amount: number
    backUrl?: string | null
    companyName?: string | null
    details?: string | null
    emailReq?: string | null
    errorCode?: string | null
    merchantEmail?: string | null
    merchantName?: string | null
    message?: string | null
    orderId: string
    paymentId: string
    phoneReq?: string | null
    success?: string | null
    tranDate?: string | null
  }

  export type payments_productbuyersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    backUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    emailReq?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    merchantEmail?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    phoneReq?: NullableStringFieldUpdateOperationsInput | string | null
    success?: NullableStringFieldUpdateOperationsInput | string | null
    tranDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payments_productbuyersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    backUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    emailReq?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    merchantEmail?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    phoneReq?: NullableStringFieldUpdateOperationsInput | string | null
    success?: NullableStringFieldUpdateOperationsInput | string | null
    tranDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payments_productbuyersCreateManyInput = {
    id?: string
    amount: number
    backUrl?: string | null
    companyName?: string | null
    details?: string | null
    emailReq?: string | null
    errorCode?: string | null
    merchantEmail?: string | null
    merchantName?: string | null
    message?: string | null
    orderId: string
    paymentId: string
    phoneReq?: string | null
    success?: string | null
    tranDate?: string | null
  }

  export type payments_productbuyersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    backUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    emailReq?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    merchantEmail?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    phoneReq?: NullableStringFieldUpdateOperationsInput | string | null
    success?: NullableStringFieldUpdateOperationsInput | string | null
    tranDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payments_productbuyersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    backUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    emailReq?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    merchantEmail?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    phoneReq?: NullableStringFieldUpdateOperationsInput | string | null
    success?: NullableStringFieldUpdateOperationsInput | string | null
    tranDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthorProductCreateInput = {
    id?: string
    email: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    is_subscribed?: boolean | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    image_file_user?: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
    ProductsProductResult?: ProductsProductResultCreateNestedManyWithoutAuthorInput
  }

  export type AuthorProductUncheckedCreateInput = {
    id?: string
    email: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    is_subscribed?: boolean | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    image_file_user?: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
    ProductsProductResult?: ProductsProductResultUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
    ProductsProductResult?: ProductsProductResultUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
    ProductsProductResult?: ProductsProductResultUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorProductCreateManyInput = {
    id?: string
    email: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    is_subscribed?: boolean | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    image_file_user?: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
  }

  export type AuthorProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthorProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TagsCreateInput = {
    name?: string | null
    color?: string | null
    slug?: string | null
    ProductsProductResult?: ProductsProductResultCreateNestedManyWithoutTagsInput
    productsProductResultId?: number | null
  }

  export type TagsUncheckedCreateInput = {
    id?: number
    name?: string | null
    color?: string | null
    slug?: string | null
    ProductsProductResult?: ProductsProductResultUncheckedCreateNestedManyWithoutTagsInput
    productsProductResultId?: number | null
  }

  export type TagsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ProductsProductResult?: ProductsProductResultUpdateManyWithoutTagsNestedInput
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    ProductsProductResult?: ProductsProductResultUncheckedUpdateManyWithoutTagsNestedInput
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsCreateManyInput = {
    id?: number
    name?: string | null
    color?: string | null
    slug?: string | null
    productsProductResultId?: number | null
  }

  export type TagsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserFavoritesProductCreateInput = {
    is_favorite?: boolean
    userId: string
    productId: string
  }

  export type UserFavoritesProductUncheckedCreateInput = {
    id?: number
    is_favorite?: boolean
    userId: string
    productId: string
  }

  export type UserFavoritesProductUpdateInput = {
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type UserFavoritesProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type UserFavoritesProductCreateManyInput = {
    id?: number
    is_favorite?: boolean
    userId: string
    productId: string
  }

  export type UserFavoritesProductUpdateManyMutationInput = {
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type UserFavoritesProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateInput = {
    count_votes?: number
    is_vote_user?: boolean
    productId?: string | null
    userId?: string | null
  }

  export type VoteUncheckedCreateInput = {
    id?: number
    count_votes?: number
    is_vote_user?: boolean
    productId?: string | null
    userId?: string | null
  }

  export type VoteUpdateInput = {
    count_votes?: IntFieldUpdateOperationsInput | number
    is_vote_user?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    count_votes?: IntFieldUpdateOperationsInput | number
    is_vote_user?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteCreateManyInput = {
    id?: number
    count_votes?: number
    is_vote_user?: boolean
    productId?: string | null
    userId?: string | null
  }

  export type VoteUpdateManyMutationInput = {
    count_votes?: IntFieldUpdateOperationsInput | number
    is_vote_user?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    count_votes?: IntFieldUpdateOperationsInput | number
    is_vote_user?: BoolFieldUpdateOperationsInput | boolean
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AccountProviderIdProviderAccountIdCompoundUniqueInput = {
    providerId: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DeliveryRelationFilter = {
    is?: DeliveryWhereInput | null
    isNot?: DeliveryWhereInput | null
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    zip?: SortOrder
    deliveryId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type VerificationRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type VerificationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type VerificationRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type product_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type product_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type product_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type product_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type product_categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type VerificationRequestListRelationFilter = {
    every?: VerificationRequestWhereInput
    some?: VerificationRequestWhereInput
    none?: VerificationRequestWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailDateVerified?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailDateVerified?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailDateVerified?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type ProductsProductResultListRelationFilter = {
    every?: ProductsProductResultWhereInput
    some?: ProductsProductResultWhereInput
    none?: ProductsProductResultWhereInput
  }

  export type ProductsProductResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsProductCountOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
  }

  export type ProductsProductAvgOrderByAggregateInput = {
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
  }

  export type ProductsProductMaxOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
  }

  export type ProductsProductMinOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
  }

  export type ProductsProductSumOrderByAggregateInput = {
    count?: SortOrder
    next?: SortOrder
    previous?: SortOrder
  }

  export type TagsListRelationFilter = {
    every?: TagsWhereInput
    some?: TagsWhereInput
    none?: TagsWhereInput
  }

  export type AuthorProductRelationFilter = {
    is?: AuthorProductWhereInput | null
    isNot?: AuthorProductWhereInput | null
  }

  export type ProductsProductListRelationFilter = {
    every?: ProductsProductWhereInput
    some?: ProductsProductWhereInput
    none?: ProductsProductWhereInput
  }

  export type TagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsProductResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    text?: SortOrder
    price_product?: SortOrder
    taxation?: SortOrder
    tax?: SortOrder
    authorProductId?: SortOrder
    productsProductId?: SortOrder
  }

  export type ProductsProductResultAvgOrderByAggregateInput = {
    price_product?: SortOrder
  }

  export type ProductsProductResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    text?: SortOrder
    price_product?: SortOrder
    taxation?: SortOrder
    tax?: SortOrder
    authorProductId?: SortOrder
    productsProductId?: SortOrder
  }

  export type ProductsProductResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    text?: SortOrder
    price_product?: SortOrder
    taxation?: SortOrder
    tax?: SortOrder
    authorProductId?: SortOrder
    productsProductId?: SortOrder
  }

  export type ProductsProductResultSumOrderByAggregateInput = {
    price_product?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    purchaseDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    deliveryId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    purchaseDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    deliveryId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    purchaseDate?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    deliveryId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
  }

  export type products_product_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_product_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_product_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_product_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_product_categorySumOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    category_id?: SortOrder
  }

  export type products_tagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    key?: SortOrder
  }

  export type products_tagAvgOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
  }

  export type products_tagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    key?: SortOrder
  }

  export type products_tagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    key?: SortOrder
  }

  export type products_tagSumOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
  }

  export type products_product_tagsCountOrderByAggregateInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type products_product_tagsAvgOrderByAggregateInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type products_product_tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type products_product_tagsMinOrderByAggregateInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type products_product_tagsSumOrderByAggregateInput = {
    id?: SortOrder
    producy_id?: SortOrder
    tag_id?: SortOrder
  }

  export type ProductsProductWhoLikesItCountOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProductsProductWhoLikesItAvgOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProductsProductWhoLikesItMaxOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProductsProductWhoLikesItMinOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type ProductsProductWhoLikesItSumOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type payments_productbuyersCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    backUrl?: SortOrder
    companyName?: SortOrder
    details?: SortOrder
    emailReq?: SortOrder
    errorCode?: SortOrder
    merchantEmail?: SortOrder
    merchantName?: SortOrder
    message?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    phoneReq?: SortOrder
    success?: SortOrder
    tranDate?: SortOrder
  }

  export type payments_productbuyersAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type payments_productbuyersMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    backUrl?: SortOrder
    companyName?: SortOrder
    details?: SortOrder
    emailReq?: SortOrder
    errorCode?: SortOrder
    merchantEmail?: SortOrder
    merchantName?: SortOrder
    message?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    phoneReq?: SortOrder
    success?: SortOrder
    tranDate?: SortOrder
  }

  export type payments_productbuyersMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    backUrl?: SortOrder
    companyName?: SortOrder
    details?: SortOrder
    emailReq?: SortOrder
    errorCode?: SortOrder
    merchantEmail?: SortOrder
    merchantName?: SortOrder
    message?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    phoneReq?: SortOrder
    success?: SortOrder
    tranDate?: SortOrder
  }

  export type payments_productbuyersSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type AuthorProductCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_subscribed?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    image_file_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    is_admin_constructor?: SortOrder
  }

  export type AuthorProductMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_subscribed?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    image_file_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    is_admin_constructor?: SortOrder
  }

  export type AuthorProductMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_subscribed?: SortOrder
    phone_user?: SortOrder
    trademark?: SortOrder
    locale_user?: SortOrder
    image_url_user?: SortOrder
    image_file_user?: SortOrder
    auth_is_telegram?: SortOrder
    auth_is_yandex?: SortOrder
    auth_is_google?: SortOrder
    is_admin_constructor?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    productsProductResultId?: SortOrder
  }

  export type TagsAvgOrderByAggregateInput = {
    id?: SortOrder
    productsProductResultId?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    productsProductResultId?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    slug?: SortOrder
    productsProductResultId?: SortOrder
  }

  export type TagsSumOrderByAggregateInput = {
    id?: SortOrder
    productsProductResultId?: SortOrder
  }

  export type UserFavoritesProductUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type UserFavoritesProductCountOrderByAggregateInput = {
    id?: SortOrder
    is_favorite?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type UserFavoritesProductAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserFavoritesProductMaxOrderByAggregateInput = {
    id?: SortOrder
    is_favorite?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type UserFavoritesProductMinOrderByAggregateInput = {
    id?: SortOrder
    is_favorite?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type UserFavoritesProductSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VoteUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    count_votes?: SortOrder
    is_vote_user?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type VoteAvgOrderByAggregateInput = {
    id?: SortOrder
    count_votes?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    count_votes?: SortOrder
    is_vote_user?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    count_votes?: SortOrder
    is_vote_user?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type VoteSumOrderByAggregateInput = {
    id?: SortOrder
    count_votes?: SortOrder
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AddressCreateNestedOneWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput
    connect?: AddressWhereUniqueInput
  }

  export type AddressUpdateOneWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput
    upsert?: AddressUpsertWithoutCityInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeliveryCreateNestedOneWithoutAddressInput = {
    create?: XOR<DeliveryCreateWithoutAddressInput, DeliveryUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutAddressInput
    connect?: DeliveryWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<CityCreateWithoutAddressInput>, Enumerable<CityUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutAddressInput>
    createMany?: CityCreateManyAddressInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<CityCreateWithoutAddressInput>, Enumerable<CityUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutAddressInput>
    createMany?: CityCreateManyAddressInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type DeliveryUpdateOneWithoutAddressNestedInput = {
    create?: XOR<DeliveryCreateWithoutAddressInput, DeliveryUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutAddressInput
    upsert?: DeliveryUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<DeliveryUpdateWithoutAddressInput, DeliveryUncheckedUpdateWithoutAddressInput>
  }

  export type CityUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutAddressInput>, Enumerable<CityUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: CityCreateManyAddressInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutAddressInput>, Enumerable<CityUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: CityCreateManyAddressInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductsInput>, Enumerable<OrderUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductsInput>, Enumerable<OrderUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type OrderUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductsInput>, Enumerable<OrderUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductsInput>, Enumerable<OrderUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutDeliveryInput>, Enumerable<AddressUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutDeliveryInput>
    createMany?: AddressCreateManyDeliveryInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDeliveryInput>, Enumerable<OrderUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDeliveryInput>
    createMany?: OrderCreateManyDeliveryInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutDeliveryInput>, Enumerable<AddressUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutDeliveryInput>
    createMany?: AddressCreateManyDeliveryInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDeliveryInput>, Enumerable<OrderUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDeliveryInput>
    createMany?: OrderCreateManyDeliveryInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutDeliveryInput>, Enumerable<AddressUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: AddressCreateManyDeliveryInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type OrderUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDeliveryInput>, Enumerable<OrderUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: OrderCreateManyDeliveryInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutDeliveryInput>, Enumerable<AddressUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: AddressCreateManyDeliveryInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutDeliveryInput>, Enumerable<OrderUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: OrderCreateManyDeliveryInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutVerifiedUsersInput = {
    create?: XOR<UserCreateWithoutVerifiedUsersInput, UserUncheckedCreateWithoutVerifiedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVerifiedUsersNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedUsersInput, UserUncheckedCreateWithoutVerifiedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedUsersInput
    upsert?: UserUpsertWithoutVerifiedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutVerifiedUsersInput, UserUncheckedUpdateWithoutVerifiedUsersInput>
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type VerificationRequestCreateNestedManyWithoutUserVerificationInput = {
    create?: XOR<Enumerable<VerificationRequestCreateWithoutUserVerificationInput>, Enumerable<VerificationRequestUncheckedCreateWithoutUserVerificationInput>>
    connectOrCreate?: Enumerable<VerificationRequestCreateOrConnectWithoutUserVerificationInput>
    createMany?: VerificationRequestCreateManyUserVerificationInputEnvelope
    connect?: Enumerable<VerificationRequestWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput = {
    create?: XOR<Enumerable<VerificationRequestCreateWithoutUserVerificationInput>, Enumerable<VerificationRequestUncheckedCreateWithoutUserVerificationInput>>
    connectOrCreate?: Enumerable<VerificationRequestCreateOrConnectWithoutUserVerificationInput>
    createMany?: VerificationRequestCreateManyUserVerificationInputEnvelope
    connect?: Enumerable<VerificationRequestWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type VerificationRequestUpdateManyWithoutUserVerificationNestedInput = {
    create?: XOR<Enumerable<VerificationRequestCreateWithoutUserVerificationInput>, Enumerable<VerificationRequestUncheckedCreateWithoutUserVerificationInput>>
    connectOrCreate?: Enumerable<VerificationRequestCreateOrConnectWithoutUserVerificationInput>
    upsert?: Enumerable<VerificationRequestUpsertWithWhereUniqueWithoutUserVerificationInput>
    createMany?: VerificationRequestCreateManyUserVerificationInputEnvelope
    set?: Enumerable<VerificationRequestWhereUniqueInput>
    disconnect?: Enumerable<VerificationRequestWhereUniqueInput>
    delete?: Enumerable<VerificationRequestWhereUniqueInput>
    connect?: Enumerable<VerificationRequestWhereUniqueInput>
    update?: Enumerable<VerificationRequestUpdateWithWhereUniqueWithoutUserVerificationInput>
    updateMany?: Enumerable<VerificationRequestUpdateManyWithWhereWithoutUserVerificationInput>
    deleteMany?: Enumerable<VerificationRequestScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutUserInput>, Enumerable<MessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MessageCreateManyUserInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput = {
    create?: XOR<Enumerable<VerificationRequestCreateWithoutUserVerificationInput>, Enumerable<VerificationRequestUncheckedCreateWithoutUserVerificationInput>>
    connectOrCreate?: Enumerable<VerificationRequestCreateOrConnectWithoutUserVerificationInput>
    upsert?: Enumerable<VerificationRequestUpsertWithWhereUniqueWithoutUserVerificationInput>
    createMany?: VerificationRequestCreateManyUserVerificationInputEnvelope
    set?: Enumerable<VerificationRequestWhereUniqueInput>
    disconnect?: Enumerable<VerificationRequestWhereUniqueInput>
    delete?: Enumerable<VerificationRequestWhereUniqueInput>
    connect?: Enumerable<VerificationRequestWhereUniqueInput>
    update?: Enumerable<VerificationRequestUpdateWithWhereUniqueWithoutUserVerificationInput>
    updateMany?: Enumerable<VerificationRequestUpdateManyWithWhereWithoutUserVerificationInput>
    deleteMany?: Enumerable<VerificationRequestScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ProductsProductResultCreateNestedManyWithoutProductsProductInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutProductsProductInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutProductsProductInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutProductsProductInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type ProductsProductResultUncheckedCreateNestedManyWithoutProductsProductInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutProductsProductInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutProductsProductInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutProductsProductInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type ProductsProductResultUpdateManyWithoutProductsProductNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutProductsProductInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutProductsProductInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutProductsProductInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutProductsProductInput>
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutProductsProductInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutProductsProductInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type ProductsProductResultUncheckedUpdateManyWithoutProductsProductNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutProductsProductInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutProductsProductInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutProductsProductInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutProductsProductInput>
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutProductsProductInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutProductsProductInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type TagsCreateNestedManyWithoutProductsProductResultInput = {
    create?: XOR<Enumerable<TagsCreateWithoutProductsProductResultInput>, Enumerable<TagsUncheckedCreateWithoutProductsProductResultInput>>
    connectOrCreate?: Enumerable<TagsCreateOrConnectWithoutProductsProductResultInput>
    connect?: Enumerable<TagsWhereUniqueInput>
  }

  export type AuthorProductCreateNestedOneWithoutProductsProductResultInput = {
    create?: XOR<AuthorProductCreateWithoutProductsProductResultInput, AuthorProductUncheckedCreateWithoutProductsProductResultInput>
    connectOrCreate?: AuthorProductCreateOrConnectWithoutProductsProductResultInput
    connect?: AuthorProductWhereUniqueInput
  }

  export type ProductsProductCreateNestedManyWithoutResultsInput = {
    create?: XOR<Enumerable<ProductsProductCreateWithoutResultsInput>, Enumerable<ProductsProductUncheckedCreateWithoutResultsInput>>
    connectOrCreate?: Enumerable<ProductsProductCreateOrConnectWithoutResultsInput>
    connect?: Enumerable<ProductsProductWhereUniqueInput>
  }

  export type TagsUncheckedCreateNestedManyWithoutProductsProductResultInput = {
    create?: XOR<Enumerable<TagsCreateWithoutProductsProductResultInput>, Enumerable<TagsUncheckedCreateWithoutProductsProductResultInput>>
    connectOrCreate?: Enumerable<TagsCreateOrConnectWithoutProductsProductResultInput>
    connect?: Enumerable<TagsWhereUniqueInput>
  }

  export type ProductsProductUncheckedCreateNestedManyWithoutResultsInput = {
    create?: XOR<Enumerable<ProductsProductCreateWithoutResultsInput>, Enumerable<ProductsProductUncheckedCreateWithoutResultsInput>>
    connectOrCreate?: Enumerable<ProductsProductCreateOrConnectWithoutResultsInput>
    connect?: Enumerable<ProductsProductWhereUniqueInput>
  }

  export type TagsUpdateManyWithoutProductsProductResultNestedInput = {
    create?: XOR<Enumerable<TagsCreateWithoutProductsProductResultInput>, Enumerable<TagsUncheckedCreateWithoutProductsProductResultInput>>
    connectOrCreate?: Enumerable<TagsCreateOrConnectWithoutProductsProductResultInput>
    upsert?: Enumerable<TagsUpsertWithWhereUniqueWithoutProductsProductResultInput>
    set?: Enumerable<TagsWhereUniqueInput>
    disconnect?: Enumerable<TagsWhereUniqueInput>
    delete?: Enumerable<TagsWhereUniqueInput>
    connect?: Enumerable<TagsWhereUniqueInput>
    update?: Enumerable<TagsUpdateWithWhereUniqueWithoutProductsProductResultInput>
    updateMany?: Enumerable<TagsUpdateManyWithWhereWithoutProductsProductResultInput>
    deleteMany?: Enumerable<TagsScalarWhereInput>
  }

  export type AuthorProductUpdateOneWithoutProductsProductResultNestedInput = {
    create?: XOR<AuthorProductCreateWithoutProductsProductResultInput, AuthorProductUncheckedCreateWithoutProductsProductResultInput>
    connectOrCreate?: AuthorProductCreateOrConnectWithoutProductsProductResultInput
    upsert?: AuthorProductUpsertWithoutProductsProductResultInput
    disconnect?: boolean
    delete?: boolean
    connect?: AuthorProductWhereUniqueInput
    update?: XOR<AuthorProductUpdateWithoutProductsProductResultInput, AuthorProductUncheckedUpdateWithoutProductsProductResultInput>
  }

  export type ProductsProductUpdateManyWithoutResultsNestedInput = {
    create?: XOR<Enumerable<ProductsProductCreateWithoutResultsInput>, Enumerable<ProductsProductUncheckedCreateWithoutResultsInput>>
    connectOrCreate?: Enumerable<ProductsProductCreateOrConnectWithoutResultsInput>
    upsert?: Enumerable<ProductsProductUpsertWithWhereUniqueWithoutResultsInput>
    set?: Enumerable<ProductsProductWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductWhereUniqueInput>
    delete?: Enumerable<ProductsProductWhereUniqueInput>
    connect?: Enumerable<ProductsProductWhereUniqueInput>
    update?: Enumerable<ProductsProductUpdateWithWhereUniqueWithoutResultsInput>
    updateMany?: Enumerable<ProductsProductUpdateManyWithWhereWithoutResultsInput>
    deleteMany?: Enumerable<ProductsProductScalarWhereInput>
  }

  export type TagsUncheckedUpdateManyWithoutProductsProductResultNestedInput = {
    create?: XOR<Enumerable<TagsCreateWithoutProductsProductResultInput>, Enumerable<TagsUncheckedCreateWithoutProductsProductResultInput>>
    connectOrCreate?: Enumerable<TagsCreateOrConnectWithoutProductsProductResultInput>
    upsert?: Enumerable<TagsUpsertWithWhereUniqueWithoutProductsProductResultInput>
    set?: Enumerable<TagsWhereUniqueInput>
    disconnect?: Enumerable<TagsWhereUniqueInput>
    delete?: Enumerable<TagsWhereUniqueInput>
    connect?: Enumerable<TagsWhereUniqueInput>
    update?: Enumerable<TagsUpdateWithWhereUniqueWithoutProductsProductResultInput>
    updateMany?: Enumerable<TagsUpdateManyWithWhereWithoutProductsProductResultInput>
    deleteMany?: Enumerable<TagsScalarWhereInput>
  }

  export type ProductsProductUncheckedUpdateManyWithoutResultsNestedInput = {
    create?: XOR<Enumerable<ProductsProductCreateWithoutResultsInput>, Enumerable<ProductsProductUncheckedCreateWithoutResultsInput>>
    connectOrCreate?: Enumerable<ProductsProductCreateOrConnectWithoutResultsInput>
    upsert?: Enumerable<ProductsProductUpsertWithWhereUniqueWithoutResultsInput>
    set?: Enumerable<ProductsProductWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductWhereUniqueInput>
    delete?: Enumerable<ProductsProductWhereUniqueInput>
    connect?: Enumerable<ProductsProductWhereUniqueInput>
    update?: Enumerable<ProductsProductUpdateWithWhereUniqueWithoutResultsInput>
    updateMany?: Enumerable<ProductsProductUpdateManyWithWhereWithoutResultsInput>
    deleteMany?: Enumerable<ProductsProductScalarWhereInput>
  }

  export type DeliveryCreateNestedOneWithoutOrdersInput = {
    create?: XOR<DeliveryCreateWithoutOrdersInput, DeliveryUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrdersInput
    connect?: DeliveryWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type DeliveryUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrdersInput, DeliveryUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrdersInput
    upsert?: DeliveryUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<DeliveryUpdateWithoutOrdersInput, DeliveryUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutOrdersInput>, Enumerable<ProductUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductsProductResultCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutAuthorInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutAuthorInput>
    createMany?: ProductsProductResultCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type ProductsProductResultUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutAuthorInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutAuthorInput>
    createMany?: ProductsProductResultCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ProductsProductResultUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutAuthorInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ProductsProductResultCreateManyAuthorInputEnvelope
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type ProductsProductResultUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutAuthorInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ProductsProductResultCreateManyAuthorInputEnvelope
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type ProductsProductResultCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutTagsInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type ProductsProductResultUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutTagsInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
  }

  export type ProductsProductResultUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutTagsInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type ProductsProductResultUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<Enumerable<ProductsProductResultCreateWithoutTagsInput>, Enumerable<ProductsProductResultUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductsProductResultCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<ProductsProductResultUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<ProductsProductResultWhereUniqueInput>
    disconnect?: Enumerable<ProductsProductResultWhereUniqueInput>
    delete?: Enumerable<ProductsProductResultWhereUniqueInput>
    connect?: Enumerable<ProductsProductResultWhereUniqueInput>
    update?: Enumerable<ProductsProductResultUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<ProductsProductResultUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<ProductsProductResultScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
    products?: ProductCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    products?: ProductCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    products?: ProductCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddressCreateWithoutCityInput = {
    zip: number
    Delivery?: DeliveryCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCityInput = {
    id?: number
    zip: number
    deliveryId?: number | null
  }

  export type AddressCreateOrConnectWithoutCityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpsertWithoutCityInput = {
    update: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpdateWithoutCityInput = {
    zip?: IntFieldUpdateOperationsInput | number
    Delivery?: DeliveryUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    zip?: IntFieldUpdateOperationsInput | number
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeliveryCreateWithoutAddressInput = {
    title: string
    orders?: OrderCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutAddressInput = {
    id?: number
    title: string
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutAddressInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutAddressInput, DeliveryUncheckedCreateWithoutAddressInput>
  }

  export type CityCreateWithoutAddressInput = {
    name: string
  }

  export type CityUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type CityCreateOrConnectWithoutAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
  }

  export type CityCreateManyAddressInputEnvelope = {
    data: Enumerable<CityCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type DeliveryUpsertWithoutAddressInput = {
    update: XOR<DeliveryUpdateWithoutAddressInput, DeliveryUncheckedUpdateWithoutAddressInput>
    create: XOR<DeliveryCreateWithoutAddressInput, DeliveryUncheckedCreateWithoutAddressInput>
  }

  export type DeliveryUpdateWithoutAddressInput = {
    title?: StringFieldUpdateOperationsInput | string
    orders?: OrderUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutAddressInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutAddressInput, CityUncheckedUpdateWithoutAddressInput>
    create: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
  }

  export type CityUpdateWithWhereUniqueWithoutAddressInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutAddressInput, CityUncheckedUpdateWithoutAddressInput>
  }

  export type CityUpdateManyWithWhereWithoutAddressInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCityInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    addressId?: IntNullableFilter | number | null
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    image?: StringFilter | string
    sku?: StringFilter | string
    quantity?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    productId?: string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    productId?: string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type OrderCreateWithoutProductsInput = {
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    Delivery?: DeliveryCreateNestedOneWithoutOrdersInput
    customer?: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    userId: string
    productId: string
    deliveryId?: number | null
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    productId?: StringNullableFilter | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: IntFilter | number
    order_id?: StringFilter | string
    purchaseDate?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: StringFilter | string
    productId?: StringFilter | string
    deliveryId?: IntNullableFilter | number | null
  }

  export type AddressCreateWithoutDeliveryInput = {
    zip: number
    city?: CityCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutDeliveryInput = {
    id?: number
    zip: number
    city?: CityUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutDeliveryInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutDeliveryInput, AddressUncheckedCreateWithoutDeliveryInput>
  }

  export type AddressCreateManyDeliveryInputEnvelope = {
    data: Enumerable<AddressCreateManyDeliveryInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutDeliveryInput = {
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    products?: ProductCreateNestedManyWithoutOrdersInput
    customer?: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutDeliveryInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    userId: string
    productId: string
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutDeliveryInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
  }

  export type OrderCreateManyDeliveryInputEnvelope = {
    data: Enumerable<OrderCreateManyDeliveryInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutDeliveryInput, AddressUncheckedUpdateWithoutDeliveryInput>
    create: XOR<AddressCreateWithoutDeliveryInput, AddressUncheckedCreateWithoutDeliveryInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutDeliveryInput, AddressUncheckedUpdateWithoutDeliveryInput>
  }

  export type AddressUpdateManyWithWhereWithoutDeliveryInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: IntFilter | number
    zip?: IntFilter | number
    deliveryId?: IntNullableFilter | number | null
  }

  export type OrderUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
  }

  export type OrderUpdateManyWithWhereWithoutDeliveryInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type UserCreateWithoutVerifiedUsersInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    products?: ProductCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerifiedUsersInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerifiedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedUsersInput, UserUncheckedCreateWithoutVerifiedUsersInput>
  }

  export type UserUpsertWithoutVerifiedUsersInput = {
    update: XOR<UserUpdateWithoutVerifiedUsersInput, UserUncheckedUpdateWithoutVerifiedUsersInput>
    create: XOR<UserCreateWithoutVerifiedUsersInput, UserUncheckedCreateWithoutVerifiedUsersInput>
  }

  export type UserUpdateWithoutVerifiedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutUserInput = {
    body: string
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: number
    body: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: Enumerable<MessageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    Delivery?: DeliveryCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    deliveryId?: number | null
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: Enumerable<OrderCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: Enumerable<ProductCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type VerificationRequestCreateWithoutUserVerificationInput = {
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUncheckedCreateWithoutUserVerificationInput = {
    id?: number
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestCreateOrConnectWithoutUserVerificationInput = {
    where: VerificationRequestWhereUniqueInput
    create: XOR<VerificationRequestCreateWithoutUserVerificationInput, VerificationRequestUncheckedCreateWithoutUserVerificationInput>
  }

  export type VerificationRequestCreateManyUserVerificationInputEnvelope = {
    data: Enumerable<VerificationRequestCreateManyUserVerificationInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    compoundId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number
    compoundId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: IntFilter | number
    body?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type VerificationRequestUpsertWithWhereUniqueWithoutUserVerificationInput = {
    where: VerificationRequestWhereUniqueInput
    update: XOR<VerificationRequestUpdateWithoutUserVerificationInput, VerificationRequestUncheckedUpdateWithoutUserVerificationInput>
    create: XOR<VerificationRequestCreateWithoutUserVerificationInput, VerificationRequestUncheckedCreateWithoutUserVerificationInput>
  }

  export type VerificationRequestUpdateWithWhereUniqueWithoutUserVerificationInput = {
    where: VerificationRequestWhereUniqueInput
    data: XOR<VerificationRequestUpdateWithoutUserVerificationInput, VerificationRequestUncheckedUpdateWithoutUserVerificationInput>
  }

  export type VerificationRequestUpdateManyWithWhereWithoutUserVerificationInput = {
    where: VerificationRequestScalarWhereInput
    data: XOR<VerificationRequestUpdateManyMutationInput, VerificationRequestUncheckedUpdateManyWithoutVerifiedUsersInput>
  }

  export type VerificationRequestScalarWhereInput = {
    AND?: Enumerable<VerificationRequestScalarWhereInput>
    OR?: Enumerable<VerificationRequestScalarWhereInput>
    NOT?: Enumerable<VerificationRequestScalarWhereInput>
    id?: IntFilter | number
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: IntFilter | number
    compoundId?: StringFilter | string
    userId?: StringFilter | string
    providerType?: StringFilter | string
    providerId?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    accessTokenExpires?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    sessionToken?: StringFilter | string
    accessToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductsProductResultCreateWithoutProductsProductInput = {
    id?: string
    tags?: TagsCreateNestedManyWithoutProductsProductResultInput
    author?: AuthorProductCreateNestedOneWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
  }

  export type ProductsProductResultUncheckedCreateWithoutProductsProductInput = {
    id?: string
    tags?: TagsUncheckedCreateNestedManyWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    authorProductId?: string | null
    productsProductId?: string | null
  }

  export type ProductsProductResultCreateOrConnectWithoutProductsProductInput = {
    where: ProductsProductResultWhereUniqueInput
    create: XOR<ProductsProductResultCreateWithoutProductsProductInput, ProductsProductResultUncheckedCreateWithoutProductsProductInput>
  }

  export type ProductsProductResultUpsertWithWhereUniqueWithoutProductsProductInput = {
    where: ProductsProductResultWhereUniqueInput
    update: XOR<ProductsProductResultUpdateWithoutProductsProductInput, ProductsProductResultUncheckedUpdateWithoutProductsProductInput>
    create: XOR<ProductsProductResultCreateWithoutProductsProductInput, ProductsProductResultUncheckedCreateWithoutProductsProductInput>
  }

  export type ProductsProductResultUpdateWithWhereUniqueWithoutProductsProductInput = {
    where: ProductsProductResultWhereUniqueInput
    data: XOR<ProductsProductResultUpdateWithoutProductsProductInput, ProductsProductResultUncheckedUpdateWithoutProductsProductInput>
  }

  export type ProductsProductResultUpdateManyWithWhereWithoutProductsProductInput = {
    where: ProductsProductResultScalarWhereInput
    data: XOR<ProductsProductResultUpdateManyMutationInput, ProductsProductResultUncheckedUpdateManyWithoutResultsInput>
  }

  export type ProductsProductResultScalarWhereInput = {
    AND?: Enumerable<ProductsProductResultScalarWhereInput>
    OR?: Enumerable<ProductsProductResultScalarWhereInput>
    NOT?: Enumerable<ProductsProductResultScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    price_product?: IntNullableFilter | number | null
    taxation?: StringNullableFilter | string | null
    tax?: StringNullableFilter | string | null
    authorProductId?: StringNullableFilter | string | null
    productsProductId?: StringNullableFilter | string | null
  }

  export type TagsCreateWithoutProductsProductResultInput = {
    name?: string | null
    color?: string | null
    slug?: string | null
    productsProductResultId?: number | null
  }

  export type TagsUncheckedCreateWithoutProductsProductResultInput = {
    id?: number
    name?: string | null
    color?: string | null
    slug?: string | null
    productsProductResultId?: number | null
  }

  export type TagsCreateOrConnectWithoutProductsProductResultInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutProductsProductResultInput, TagsUncheckedCreateWithoutProductsProductResultInput>
  }

  export type AuthorProductCreateWithoutProductsProductResultInput = {
    id?: string
    email: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    is_subscribed?: boolean | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    image_file_user?: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
  }

  export type AuthorProductUncheckedCreateWithoutProductsProductResultInput = {
    id?: string
    email: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    is_subscribed?: boolean | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    image_file_user?: string | null
    auth_is_telegram: boolean
    auth_is_yandex: boolean
    auth_is_google: boolean
    is_admin_constructor: boolean
  }

  export type AuthorProductCreateOrConnectWithoutProductsProductResultInput = {
    where: AuthorProductWhereUniqueInput
    create: XOR<AuthorProductCreateWithoutProductsProductResultInput, AuthorProductUncheckedCreateWithoutProductsProductResultInput>
  }

  export type ProductsProductCreateWithoutResultsInput = {
    id?: string
    count: number
    next: number
    previous: number
  }

  export type ProductsProductUncheckedCreateWithoutResultsInput = {
    id?: string
    count: number
    next: number
    previous: number
  }

  export type ProductsProductCreateOrConnectWithoutResultsInput = {
    where: ProductsProductWhereUniqueInput
    create: XOR<ProductsProductCreateWithoutResultsInput, ProductsProductUncheckedCreateWithoutResultsInput>
  }

  export type TagsUpsertWithWhereUniqueWithoutProductsProductResultInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutProductsProductResultInput, TagsUncheckedUpdateWithoutProductsProductResultInput>
    create: XOR<TagsCreateWithoutProductsProductResultInput, TagsUncheckedCreateWithoutProductsProductResultInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutProductsProductResultInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutProductsProductResultInput, TagsUncheckedUpdateWithoutProductsProductResultInput>
  }

  export type TagsUpdateManyWithWhereWithoutProductsProductResultInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutTagsInput>
  }

  export type TagsScalarWhereInput = {
    AND?: Enumerable<TagsScalarWhereInput>
    OR?: Enumerable<TagsScalarWhereInput>
    NOT?: Enumerable<TagsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    productsProductResultId?: IntNullableFilter | number | null
  }

  export type AuthorProductUpsertWithoutProductsProductResultInput = {
    update: XOR<AuthorProductUpdateWithoutProductsProductResultInput, AuthorProductUncheckedUpdateWithoutProductsProductResultInput>
    create: XOR<AuthorProductCreateWithoutProductsProductResultInput, AuthorProductUncheckedCreateWithoutProductsProductResultInput>
  }

  export type AuthorProductUpdateWithoutProductsProductResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthorProductUncheckedUpdateWithoutProductsProductResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_subscribed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_file_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    is_admin_constructor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductsProductUpsertWithWhereUniqueWithoutResultsInput = {
    where: ProductsProductWhereUniqueInput
    update: XOR<ProductsProductUpdateWithoutResultsInput, ProductsProductUncheckedUpdateWithoutResultsInput>
    create: XOR<ProductsProductCreateWithoutResultsInput, ProductsProductUncheckedCreateWithoutResultsInput>
  }

  export type ProductsProductUpdateWithWhereUniqueWithoutResultsInput = {
    where: ProductsProductWhereUniqueInput
    data: XOR<ProductsProductUpdateWithoutResultsInput, ProductsProductUncheckedUpdateWithoutResultsInput>
  }

  export type ProductsProductUpdateManyWithWhereWithoutResultsInput = {
    where: ProductsProductScalarWhereInput
    data: XOR<ProductsProductUpdateManyMutationInput, ProductsProductUncheckedUpdateManyWithoutProductsProductInput>
  }

  export type ProductsProductScalarWhereInput = {
    AND?: Enumerable<ProductsProductScalarWhereInput>
    OR?: Enumerable<ProductsProductScalarWhereInput>
    NOT?: Enumerable<ProductsProductScalarWhereInput>
    id?: StringFilter | string
    count?: IntFilter | number
    next?: IntFilter | number
    previous?: IntFilter | number
  }

  export type DeliveryCreateWithoutOrdersInput = {
    title: string
    address?: AddressCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutOrdersInput = {
    id?: number
    title: string
    address?: AddressUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutOrdersInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutOrdersInput, DeliveryUncheckedCreateWithoutOrdersInput>
  }

  export type ProductCreateWithoutOrdersInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_user?: string | null
    trademark?: string | null
    locale_user?: string | null
    image_url_user?: string | null
    auth_is_telegram?: boolean
    auth_is_yandex?: boolean
    auth_is_google?: boolean
    role?: string
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailDateVerified?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    verifiedUsers?: VerificationRequestUncheckedCreateNestedManyWithoutUserVerificationInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type DeliveryUpsertWithoutOrdersInput = {
    update: XOR<DeliveryUpdateWithoutOrdersInput, DeliveryUncheckedUpdateWithoutOrdersInput>
    create: XOR<DeliveryCreateWithoutOrdersInput, DeliveryUncheckedCreateWithoutOrdersInput>
  }

  export type DeliveryUpdateWithoutOrdersInput = {
    title?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrdersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_user?: NullableStringFieldUpdateOperationsInput | string | null
    trademark?: NullableStringFieldUpdateOperationsInput | string | null
    locale_user?: NullableStringFieldUpdateOperationsInput | string | null
    image_url_user?: NullableStringFieldUpdateOperationsInput | string | null
    auth_is_telegram?: BoolFieldUpdateOperationsInput | boolean
    auth_is_yandex?: BoolFieldUpdateOperationsInput | boolean
    auth_is_google?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailDateVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    verifiedUsers?: VerificationRequestUncheckedUpdateManyWithoutUserVerificationNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsProductResultCreateWithoutAuthorInput = {
    id?: string
    tags?: TagsCreateNestedManyWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultUncheckedCreateWithoutAuthorInput = {
    id?: string
    tags?: TagsUncheckedCreateNestedManyWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductUncheckedCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultCreateOrConnectWithoutAuthorInput = {
    where: ProductsProductResultWhereUniqueInput
    create: XOR<ProductsProductResultCreateWithoutAuthorInput, ProductsProductResultUncheckedCreateWithoutAuthorInput>
  }

  export type ProductsProductResultCreateManyAuthorInputEnvelope = {
    data: Enumerable<ProductsProductResultCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ProductsProductResultUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProductsProductResultWhereUniqueInput
    update: XOR<ProductsProductResultUpdateWithoutAuthorInput, ProductsProductResultUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProductsProductResultCreateWithoutAuthorInput, ProductsProductResultUncheckedCreateWithoutAuthorInput>
  }

  export type ProductsProductResultUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProductsProductResultWhereUniqueInput
    data: XOR<ProductsProductResultUpdateWithoutAuthorInput, ProductsProductResultUncheckedUpdateWithoutAuthorInput>
  }

  export type ProductsProductResultUpdateManyWithWhereWithoutAuthorInput = {
    where: ProductsProductResultScalarWhereInput
    data: XOR<ProductsProductResultUpdateManyMutationInput, ProductsProductResultUncheckedUpdateManyWithoutProductsProductResultInput>
  }

  export type ProductsProductResultCreateWithoutTagsInput = {
    id?: string
    author?: AuthorProductCreateNestedOneWithoutProductsProductResultInput
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultUncheckedCreateWithoutTagsInput = {
    id?: string
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    authorProductId?: string | null
    productsProductId?: string | null
    productsProduct?: ProductsProductUncheckedCreateNestedManyWithoutResultsInput
  }

  export type ProductsProductResultCreateOrConnectWithoutTagsInput = {
    where: ProductsProductResultWhereUniqueInput
    create: XOR<ProductsProductResultCreateWithoutTagsInput, ProductsProductResultUncheckedCreateWithoutTagsInput>
  }

  export type ProductsProductResultUpsertWithWhereUniqueWithoutTagsInput = {
    where: ProductsProductResultWhereUniqueInput
    update: XOR<ProductsProductResultUpdateWithoutTagsInput, ProductsProductResultUncheckedUpdateWithoutTagsInput>
    create: XOR<ProductsProductResultCreateWithoutTagsInput, ProductsProductResultUncheckedCreateWithoutTagsInput>
  }

  export type ProductsProductResultUpdateWithWhereUniqueWithoutTagsInput = {
    where: ProductsProductResultWhereUniqueInput
    data: XOR<ProductsProductResultUpdateWithoutTagsInput, ProductsProductResultUncheckedUpdateWithoutTagsInput>
  }

  export type ProductsProductResultUpdateManyWithWhereWithoutTagsInput = {
    where: ProductsProductResultScalarWhereInput
    data: XOR<ProductsProductResultUpdateManyMutationInput, ProductsProductResultUncheckedUpdateManyWithoutProductsProductResultInput>
  }

  export type CityCreateManyAddressInput = {
    id?: number
    name: string
  }

  export type CityUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutProductsInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    Delivery?: DeliveryUpdateOneWithoutOrdersNestedInput
    customer?: UserUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressCreateManyDeliveryInput = {
    id?: number
    zip: number
  }

  export type OrderCreateManyDeliveryInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    userId: string
    productId: string
  }

  export type AddressUpdateWithoutDeliveryInput = {
    zip?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    zip?: IntFieldUpdateOperationsInput | number
    city?: CityUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type OrderUpdateWithoutDeliveryInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutOrdersNestedInput
    customer?: UserUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type MessageCreateManyUserInput = {
    id?: number
    body: string
    createdAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    order_id?: string
    purchaseDate?: Date | string
    description: string
    productId: string
    deliveryId?: number | null
  }

  export type ProductCreateManyUserInput = {
    id?: string
    title: string
    description: string
    image: string
    sku: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestCreateManyUserVerificationInput = {
    id?: number
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: number
    compoundId: string
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: number
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutUserInput = {
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    Delivery?: DeliveryUpdateOneWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableIntFieldUpdateOperationsInput | number | null
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type VerificationRequestUpdateWithoutUserVerificationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateWithoutUserVerificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateManyWithoutVerifiedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    compoundId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsProductResultUpdateWithoutProductsProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUpdateManyWithoutProductsProductResultNestedInput
    author?: AuthorProductUpdateOneWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsProductResultUncheckedUpdateWithoutProductsProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUncheckedUpdateManyWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    authorProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsProductResultUncheckedUpdateManyWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    authorProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsUpdateWithoutProductsProductResultInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsUncheckedUpdateWithoutProductsProductResultInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductResultId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductsProductUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
  }

  export type ProductsProductUncheckedUpdateManyWithoutProductsProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    next?: IntFieldUpdateOperationsInput | number
    previous?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProductsNestedInput
    categories?: CategoryUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsProductResultCreateManyAuthorInput = {
    id?: string
    userId?: string | null
    name?: string | null
    image?: string | null
    text?: string | null
    price_product?: number | null
    taxation?: string | null
    tax?: string | null
    productsProductId?: string | null
  }

  export type ProductsProductResultUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUpdateManyWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUpdateManyWithoutResultsNestedInput
  }

  export type ProductsProductResultUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: TagsUncheckedUpdateManyWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUncheckedUpdateManyWithoutResultsNestedInput
  }

  export type ProductsProductResultUncheckedUpdateManyWithoutProductsProductResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsProductResultUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: AuthorProductUpdateOneWithoutProductsProductResultNestedInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUpdateManyWithoutResultsNestedInput
  }

  export type ProductsProductResultUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    price_product?: NullableIntFieldUpdateOperationsInput | number | null
    taxation?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    authorProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProductId?: NullableStringFieldUpdateOperationsInput | string | null
    productsProduct?: ProductsProductUncheckedUpdateManyWithoutResultsNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}